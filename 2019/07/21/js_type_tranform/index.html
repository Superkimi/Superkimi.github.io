<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>javascript基础-类型转换 | SuperKimi</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="javascript基础,">
  

  <meta name="description" content="js类型转换1 用于类型转换的valueOf和toString valueOf()的意义是，返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。 toString()的意义是，返回这个对象的字符串表示。用一个字符串来描述这个对象的内容。  基本类型的valueOf会返回自身的原始类型，而Array、Function、Object都">
<meta name="keywords" content="javascript基础">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript基础-类型转换">
<meta property="og:url" content="/2019/07/21/js_type_tranform/index.html">
<meta property="og:site_name" content="SuperKimi">
<meta property="og:description" content="js类型转换1 用于类型转换的valueOf和toString valueOf()的意义是，返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。 toString()的意义是，返回这个对象的字符串表示。用一个字符串来描述这个对象的内容。  基本类型的valueOf会返回自身的原始类型，而Array、Function、Object都">
<meta property="og:locale" content="default">
<meta property="og:image" content="/images/to.jpg">
<meta property="og:image" content="/images/tra.png">
<meta property="og:updated_time" content="2019-08-25T10:25:34.876Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript基础-类型转换">
<meta name="twitter:description" content="js类型转换1 用于类型转换的valueOf和toString valueOf()的意义是，返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。 toString()的意义是，返回这个对象的字符串表示。用一个字符串来描述这个对象的内容。  基本类型的valueOf会返回自身的原始类型，而Array、Function、Object都">
<meta name="twitter:image" content="/images/to.jpg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016sfsf1fba3xxxx8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">主页</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">主页</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js类型转换"><span class="toc-text">js类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-用于类型转换的valueOf和toString"><span class="toc-text">1 用于类型转换的valueOf和toString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-用于检测类型的四个js内部方法"><span class="toc-text">2 用于检测类型的四个js内部方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ToPrimitive-input-PreferredType"><span class="toc-text">ToPrimitive ( input [ , PreferredType ] )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToBoolean-argument"><span class="toc-text">ToBoolean ( argument )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToNumber-argument"><span class="toc-text">ToNumber ( argument )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToString-argument"><span class="toc-text">ToString ( argument )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-隐式类型转换（自动类型转换）"><span class="toc-text">3 隐式类型转换（自动类型转换）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加法"><span class="toc-text">加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#比较运算符"><span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双等"><span class="toc-text">== 双等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-显式类型转换（强制类型转换）"><span class="toc-text">4 显式类型转换（强制类型转换）</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-js_type_tranform" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">javascript基础-类型转换</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.07.21</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Super kimi</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="js类型转换"><a href="#js类型转换" class="headerlink" title="js类型转换"></a>js类型转换</h1><h2 id="1-用于类型转换的valueOf和toString"><a href="#1-用于类型转换的valueOf和toString" class="headerlink" title="1 用于类型转换的valueOf和toString"></a>1 用于类型转换的valueOf和toString</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="noopener">valueOf()</a>的意义是，返回这个对象<strong>逻辑上对应的</strong>原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">toString()</a>的意义是，返回这个对象的字符串表示。<strong>用一个字符串来描述这个对象的内容。</strong></li>
</ul>
<p><strong>基本类型的valueOf会返回自身的原始类型，而Array、Function、Object都返回自身，Date返回时间戳，Error和Math没有valueOf方法</strong></p>
<h2 id="2-用于检测类型的四个js内部方法"><a href="#2-用于检测类型的四个js内部方法" class="headerlink" title="2 用于检测类型的四个js内部方法"></a>2 用于检测类型的四个js内部方法</h2><p>这4个方法实际上是<a href="https://tc39.github.io/ecma262/#sec-type-conversion" target="_blank" rel="noopener">ECMAScript定义的4个抽象的操作</a>，它们在js内部使用，进行类型转换。我们js的使用者不能直接调用这些函数，但是了解这些函数有利于我们理解js类型转换的原理。</p>
<ul>
<li>ToPrimitive ( input [ , PreferredType ] )</li>
<li>ToBoolean ( argument )</li>
<li>ToNumber ( argument )</li>
<li>ToString ( argument )</li>
</ul>
<blockquote>
<p>请区分这里的ToString()和上文谈到的toString()，一个是js引擎内部使用的函数，另一个是定义在对象上的函数。</p>
</blockquote>
<h3 id="ToPrimitive-input-PreferredType"><a href="#ToPrimitive-input-PreferredType" class="headerlink" title="ToPrimitive ( input [ , PreferredType ] )"></a>ToPrimitive ( input [ , PreferredType ] )</h3><p>将input转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number 或 String。<strong>如果PreferredType参数是Number</strong>，ToPrimitive这样执行：</p>
<ol>
<li>如果input本身就是原始类型，直接返回input。</li>
<li>调用<strong>input.valueOf()</strong>，如果结果是原始类型，则返回这个结果。</li>
<li>调用<strong>input.toString()</strong>，如果结果是原始类型，则返回这个结果。</li>
<li>抛出TypeError异常。</li>
</ol>
<p><strong>以下是PreferredType不为Number时的执行顺序。</strong></p>
<ul>
<li>如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。</li>
<li>如果PreferredType参数没有传入<ul>
<li>如果input是内置的Date类型，PreferredType 视为String</li>
<li>否则PreferredType 视为 Number – 先调用valueOf 再调用toString</li>
</ul>
</li>
</ul>
<blockquote>
<p>Date 转换的时候PreferredType 视为String先调用toString。所以console.log(111 + new Date())  // “111Thu Jul 25 2019 22:34:51 GMT+0800 (中国标准时间)”</p>
</blockquote>
<blockquote>
<p><strong>可以看出，ToPrimitive依赖于valueOf和toString的实现。</strong><br><img src="/images/to.jpg" alt="toPrimitive.jpg"></p>
</blockquote>
<h3 id="ToBoolean-argument"><a href="#ToBoolean-argument" class="headerlink" title="ToBoolean ( argument )"></a>ToBoolean ( argument )</h3><table>
<thead>
<tr>
<th>Argument Type</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>Return false</td>
</tr>
<tr>
<td>Null</td>
<td>Return false</td>
</tr>
<tr>
<td>Boolean</td>
<td>Return argument</td>
</tr>
<tr>
<td>Number</td>
<td>仅当argument为 +0, -0, or NaN时， return false; 否则一律 return true</td>
</tr>
<tr>
<td>String</td>
<td>仅当argument是空字符串（长度为0）时， return false; 否则一律 return true</td>
</tr>
<tr>
<td>Symbol</td>
<td>Return true</td>
</tr>
<tr>
<td>Object</td>
<td>Return true</td>
</tr>
</tbody></table>
<p>这些规定都来自<a href="https://tc39.github.io/ecma262/#sec-toboolean" target="_blank" rel="noopener">ECMA的标准</a>，在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。</p>
<h3 id="ToNumber-argument"><a href="#ToNumber-argument" class="headerlink" title="ToNumber ( argument )"></a>ToNumber ( argument )</h3><table>
<thead>
<tr>
<th>Argument Type</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>Return NaN</td>
</tr>
<tr>
<td>Null</td>
<td>Return +0</td>
</tr>
<tr>
<td>Boolean</td>
<td>如果 argument 为 true, return 1. 如果 argument 为 false, return +0</td>
</tr>
<tr>
<td>Number</td>
<td>直接返回argument</td>
</tr>
<tr>
<td>String</td>
<td>将字符串中的内容转化为数字（比如”23”-&gt;23），如果转化失败则返回NaN（比如”23a”-&gt;NaN）</td>
</tr>
<tr>
<td>Symbol</td>
<td>抛出 TypeError 异常</td>
</tr>
<tr>
<td>Object</td>
<td>先<strong>primValue = ToPrimitive(argument, Number)</strong>，再对primValue 使用 ToNumber(primValue)</td>
</tr>
</tbody></table>
<p>由上表可见ToNumber的转化并不总是成功，有时会转化成NaN，有时则直接抛出异常。</p>
<blockquote>
<p>所以Number([1,2]) -&gt; 先由ToPrimitive(argument, Number)转换[1,2]  -&gt; valueOf返回本身，再调用toString返回’1,2’ -&gt; 再ToNumber(primValue) 转换为NaN</p>
</blockquote>
<h3 id="ToString-argument"><a href="#ToString-argument" class="headerlink" title="ToString ( argument )"></a>ToString ( argument )</h3><table>
<thead>
<tr>
<th>Argument Type</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>Return “undefined”</td>
</tr>
<tr>
<td>Null</td>
<td>Return “null”</td>
</tr>
<tr>
<td>Boolean</td>
<td>如果 argument 为 true, return “true”.如果 argument 为 false, return “false”</td>
</tr>
<tr>
<td>Number</td>
<td>用字符串来表示这个数字</td>
</tr>
<tr>
<td>String</td>
<td>直接返回 argument</td>
</tr>
<tr>
<td>Symbol</td>
<td>抛出 TypeError 异常</td>
</tr>
<tr>
<td>Object</td>
<td>先primValue = ToPrimitive(argument, hint String)，再对primValue使用ToString(primValue)</td>
</tr>
</tbody></table>
<p><img src="/images/tra.png" alt="2.png"></p>
<h2 id="3-隐式类型转换（自动类型转换）"><a href="#3-隐式类型转换（自动类型转换）" class="headerlink" title="3 隐式类型转换（自动类型转换）"></a>3 隐式类型转换（自动类型转换）</h2><p>当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。</p>
<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ( !undefined</span><br><span class="line">  &amp;&amp; !null</span><br><span class="line">  &amp;&amp; !0</span><br><span class="line">  &amp;&amp; !NaN</span><br><span class="line">  &amp;&amp; !&apos;&apos;</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // true</span><br></pre></td></tr></table></figure>

<p>例子1：因为在if的括号中，js期望得到boolean的值，所以对括号中每一个值都使用ToBoolean ( argument )，将它们转化成boolean。</p>
<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 * &#123; valueOf: function () &#123; return 5 &#125; &#125;;  //15</span><br></pre></td></tr></table></figure>

<p>例子2：因为在乘号的两端，js期望得到number类型的值，所以对右边的那个对象使用ToNumber ( argument )，得到结果5，再与乘号左边的3相乘。</p>
<p>例子3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; function returnObject() &#123; return &#123;&#125; &#125;</span><br><span class="line">&gt; 3 * &#123; valueOf: function () &#123; return &#123;&#125; &#125;, toString: function () &#123; return &#123;&#125; &#125; &#125;</span><br><span class="line">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>

<p>例子3：调用ToNumber ( argument )的过程中，调用了ToPrimitive ( input , Number )，因为在ToPrimitive中valueOf和toString都没有返回原始类型，所以抛出异常。</p>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>符号’+’是一个比较棘手的一个符号，因为它既可以表示“算数加法”，也可以表示“字符串拼接”。<br>简单理解版本：只要’+’两端的任意一个操作数是字符串，那么这个’+’就表示字符串拼接，否则表示算数加法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12+3</span><br><span class="line">// 15</span><br><span class="line">12+&apos;3&apos;</span><br><span class="line">// &quot;123&quot;</span><br></pre></td></tr></table></figure>

<p>原理理解版本：根据<a href="https://tc39.github.io/ecma262/#sec-addition-operator-plus" target="_blank" rel="noopener">ECMAScript的定义</a>，对’+’运算的求值按照以下过程：</p>
<ol>
<li>令lval = 符号左边的值，rval = 符号右边的值</li>
<li>令lprim = ToPrimitive(lval)，rprim = ToPrimitive(rval)</li>
<li><ul>
<li>如果lprim和rprim中<strong>有任意一个为string类型</strong>，将ToString(lprim)和ToString(rprim)的结果做字符串拼接</li>
</ul>
</li>
</ol>
<ul>
<li>否则，将ToNumber(lprim)和ToNumber(rprim)的结果做算数加法</li>
</ul>
<p>根据这个原理可以解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[]+[]</span><br><span class="line">//  &quot;&quot;</span><br><span class="line">// 提示：ToPrimitive([])返回空字符串</span><br><span class="line"></span><br><span class="line">[] + &#123;&#125;</span><br><span class="line">//  &quot;[object Object]&quot;</span><br><span class="line">//  提示：ToPrimitive(&#123;&#125;)返回&quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">123 + &#123; toString: function () &#123; return &quot;def&quot; &#125; &#125;</span><br><span class="line">//  &quot;123def&quot;</span><br><span class="line">//  提示：ToPrimitive(加号右边的对象)返回&quot;def&quot;</span><br><span class="line"></span><br><span class="line">&#123;&#125; + []</span><br><span class="line">//  0</span><br><span class="line">// 结果不符合我们的预期：&quot;[object Object]&quot;</span><br><span class="line">// 提示：在Chrome中，符号左边的&#123;&#125;被解释成了一个语句块，而不是一个对象</span><br><span class="line">// 注意在别的执行引擎上可能会将&#123;&#125;解释成对象</span><br><span class="line">//  这一行等价于&apos;+[]&apos;</span><br><span class="line">// &apos;+anyValue&apos;等价于Number(anyValue)</span><br><span class="line"></span><br><span class="line">(&#123;&#125;) + []</span><br><span class="line">//  &quot;[object Object]&quot;</span><br><span class="line">// 加上括号以后，&#123;&#125;被解释成了一个对象，结果符合我们的预期了</span><br></pre></td></tr></table></figure>

<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; + + &apos;b&apos; // -&gt; &quot;aNaN&quot;</span><br></pre></td></tr></table></figure>

<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。相当于调用ToNumber方法</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ol>
<li>如果是对象，就通过 toPrimitive 转换对象</li>
<li>如果是字符串，就通过 unicode 字符索引来比较<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;1&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; -1 // true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="双等"><a href="#双等" class="headerlink" title="== 双等"></a>== 双等</h3><blockquote>
<p>xy都为Null或undefined,return true; 一方为Null或undefined，return false<br>x或y为NaN, return false;<br>如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较<br>如果存在Object，转换为原始值，再比较</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;0&quot; == null; // false</span><br><span class="line">&quot;0&quot; == undefined; // false</span><br><span class="line">&quot;0&quot; == false; // true ！</span><br><span class="line">&quot;0&quot; == NaN; // false</span><br><span class="line">&quot;0&quot; == 0; // true</span><br><span class="line">&quot;0&quot; == &quot;&quot;; // false</span><br><span class="line">false == null; // false</span><br><span class="line">false == undefined; // false</span><br><span class="line">false == NaN; // false</span><br><span class="line">false == 0; // true ！</span><br><span class="line">false == &quot;&quot;; // true ！</span><br><span class="line">false == []; // true ！</span><br><span class="line">false == &#123;&#125;; // false</span><br><span class="line">&quot;&quot; == null; // false</span><br><span class="line">&quot;&quot; == undefined; // false</span><br><span class="line">&quot;&quot; == NaN; // false</span><br><span class="line">&quot;&quot; == 0; // true ！</span><br><span class="line">&quot;&quot; == []; // true ！</span><br><span class="line">&quot;&quot; == &#123;&#125;; // false</span><br><span class="line">0 == null; // false</span><br><span class="line">0 == undefined; // false</span><br><span class="line">0 == NaN; // false</span><br><span class="line">0 == []; // true ！</span><br><span class="line">0 == &#123;&#125;; // false</span><br></pre></td></tr></table></figure>

<h2 id="4-显式类型转换（强制类型转换）"><a href="#4-显式类型转换（强制类型转换）" class="headerlink" title="4 显式类型转换（强制类型转换）"></a>4 显式类型转换（强制类型转换）</h2><p>程序员显式调用Boolean(value)、Number(value)、String(value)完成的类型转换，叫做显示类型转换。<br>我们在文章的前面说过new Boolean(value)、new Number(value)、new String(value)传入各自对应的原始类型的值，可以实现“装箱”——将原始类型封装成一个对象。其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&apos;sdfsd&apos;);  //  true</span><br><span class="line">Number(&quot;23&quot;);  //  23</span><br><span class="line">String(&#123;a:24&#125;);  //  &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p>其实这三个函数用于类型转换的时候，调用的就是js内部的<code>ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )</code>方法！<br>Number()比parseInt parseFloat严格。parseInt parseFloat会只截取数字转换</p>
<p>这里解释一下<code>String({a:24}); // &quot;[object Object]&quot;</code>的过程：</p>
<ul>
<li>执行String({a:24})<ul>
<li>执行js内部函数ToString ( {a:24} )<ul>
<li>执行<code>primValue = ToPrimitive({a:24}, hint String)</code><ol>
<li>因为{a:24}不是原始类型，进入下一步。</li>
<li>在ToPrimitive内调用({a:24}).toString()，返回了原始值”[object Object]”，因此直接返回这个字符串，ToPrimitive后面的步骤不用进行下去了。</li>
</ol>
</li>
<li>primValue被赋值为ToPrimitive的返回值：”[object Object]”</li>
<li>执行js内部函数ToString ( “[object Object]” )，返回”[object Object]”</li>
<li>返回”[object Object]”</li>
</ul>
</li>
<li>返回”[object Object]”</li>
</ul>
</li>
<li>返回”[object Object]”</li>
</ul>
<blockquote>
<p>为了防止出现意料之外的结果，<strong>最好在不确定的地方使用显式类型转换</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = &#123;</span><br><span class="line">	valueOf() &#123;</span><br><span class="line">		return 2</span><br><span class="line">	&#125;,</span><br><span class="line">	toString()&#123;</span><br><span class="line">		return []</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">String(obj2)  // &apos;2&apos;</span><br><span class="line">2 + obj2   // 4</span><br></pre></td></tr></table></figure>

<p>当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;1&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 + a // =&gt; 3</span><br></pre></td></tr></table></figure>

<p>parseInt()<br>   parseInt只会转换字符串。如果传入的不是字符串会先转换成字符串再进行parse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	valueOf:function() &#123;return &apos;2px&apos;&#125;,</span><br><span class="line">	toString: function() &#123;return []&#125;</span><br><span class="line">&#125;</span><br><span class="line">parseInt(obj)  // 2  如果不是字符串会先根据ToString规则转换成字符串。再去转换</span><br><span class="line"></span><br><span class="line">parseInt(1/0, 19) // 18  =&gt; 1/0转换成字符串为Infinity 。而有效数字范围是0-9 a-i 所以第一位为I 代表18。n超出19的范围了所以只有18返回</span><br><span class="line">parseInt(0.0000008) // 8 =&gt; 8e+7  6个0转换成字符串会转换成指数</span><br><span class="line">parseInt(0.000008) // 0 =&gt; 0.000008 </span><br><span class="line">parseInt(false, 16) // 250 =&gt; &apos;false&apos; =&gt; &apos;fa&apos;在16进制下有效</span><br><span class="line">parseInt(function()&#123;...&#125;, 16) // 15 =&gt; &apos;f&apos;在16进制下有效</span><br></pre></td></tr></table></figure>

<p>如果不填写第二个参数，则会根据传入的值来判断是什么进制，填写了代表转换成多少进制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;0x10&apos;)  // 16</span><br><span class="line">parseInt(&apos;103&apos;, 2)  // 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tip: </p>
<ol>
<li>~运算符可以表示 -(x+1)   : ~2 =&gt; -3  ~-1 =&gt; 0  根据这个特性。可以对-1进行特殊判断。比如indexof时 。if( ~a. indexof(‘bbb’) )  表示如果是-1就会返回false。</li>
<li>3.2 | 0  =&gt; 3;   -6.7 | 0  =&gt; -6</li>
</ol>
</blockquote>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持superkimi</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/07/21/js_type/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/07/26/js_cors/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
