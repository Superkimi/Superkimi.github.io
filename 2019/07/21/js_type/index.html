<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>javascript基础-数据类型 | SuperKimi</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="javascript基础,">
  

  <meta name="description" content="js 数据类型  js中有六种原始类型：  number boolean null undefined string symbol一种引用类型 object  引用类型和基本类型有什么区别，以及深浅拷贝之类就暂时不表了。  注意点：  undefined和not defined是不同的 。undefined代表的是定义了但是没有赋值，not defined表示没有定义。但是typeof 都返回un">
<meta name="keywords" content="javascript基础">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript基础-数据类型">
<meta property="og:url" content="/2019/07/21/js_type/index.html">
<meta property="og:site_name" content="SuperKimi">
<meta property="og:description" content="js 数据类型  js中有六种原始类型：  number boolean null undefined string symbol一种引用类型 object  引用类型和基本类型有什么区别，以及深浅拷贝之类就暂时不表了。  注意点：  undefined和not defined是不同的 。undefined代表的是定义了但是没有赋值，not defined表示没有定义。但是typeof 都返回un">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-25T10:25:30.939Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript基础-数据类型">
<meta name="twitter:description" content="js 数据类型  js中有六种原始类型：  number boolean null undefined string symbol一种引用类型 object  引用类型和基本类型有什么区别，以及深浅拷贝之类就暂时不表了。  注意点：  undefined和not defined是不同的 。undefined代表的是定义了但是没有赋值，not defined表示没有定义。但是typeof 都返回un">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016sfsf1fba3xxxx8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">主页</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">主页</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js-数据类型"><span class="toc-text">js 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-typeof"><span class="toc-text">1 typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-字面量、String-、new-String"><span class="toc-text">2 字面量、String()、new String()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-准确类型判断方法"><span class="toc-text">3 准确类型判断方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-instanceof-配合-typeof"><span class="toc-text">1. instanceof 配合 typeof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-prototype-toString-call"><span class="toc-text">2. Object.prototype.toString.call()</span></a></li></ol></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-js_type" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">javascript基础-数据类型</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.07.21</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Super kimi</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h1><p>  js中有六种原始类型：</p>
<ul>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>string</li>
<li>symbol<br>一种引用类型</li>
<li>object</li>
</ul>
<p>引用类型和基本类型有什么区别，以及深浅拷贝之类就暂时不表了。</p>
<blockquote>
<p><code>注意点：</code></p>
<ol>
<li>undefined和not defined是不同的 。undefined代表的是定义了但是没有赋值，not defined表示没有定义。但是typeof 都返回undefined。</li>
<li>js中的string是不可变的，他的成员函数不会改变原值，而是创建并返回一个新的字符串。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a.toUpperCase();</span><br><span class="line">a === c // false</span><br></pre></td></tr></table></figure>

<h2 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1 typeof"></a>1 typeof</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof false // boolean</span><br><span class="line">typeof null // object</span><br><span class="line">typeof undefined // undefined</span><br><span class="line">typeof 2 // number</span><br><span class="line">typeof NaN // number</span><br><span class="line">typeof Infinity // number</span><br><span class="line">typeof &apos;kimi&apos; // string</span><br><span class="line">typeof Symbol(&apos;kimi&apos;) // symbol</span><br><span class="line"></span><br><span class="line">typeof Date // funtion</span><br><span class="line">typeof [2,2,3] // object</span><br><span class="line">typeof &#123;a:1&#125; // object</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>使用typeof检测基本类型基本可以正确的判断出类型的，但是判断引用类型时就没有那么准确了。因为数组、对象、函数实际上都是引用类型。但function对象和普通的对象相比，其内部有一个<strong>[[call]]</strong>方法，用来表示这个对象是可调用的。所以返回时function。实际<strong>函数就是一个可调用对象。</strong>如果要准确的判断各个引用类型就需要使用<strong>instanceof</strong>。</li>
<li>null返回object。这是js的一个bug，js最初版本使用的是32位系统，为了性能考虑用低位存储变量的类型信息，<strong>000</strong>开头表示对象，然后null为<strong>全零</strong>。所以返回object。现在内部类型判断代码已经改变。但是这个bug仍然在。<strong>所以null其实算做基本类型</strong></li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null instanceof object // false</span><br></pre></td></tr></table></figure>

<h2 id="2-字面量、String-、new-String"><a href="#2-字面量、String-、new-String" class="headerlink" title="2 字面量、String()、new String()"></a>2 字面量、String()、new String()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var abc = &apos;abc&apos;,</span><br><span class="line">    str1 = String(abc),</span><br><span class="line">    str2 = new String(abc);</span><br><span class="line">//判断下面输出</span><br><span class="line">str1 === abc   //true</span><br><span class="line">str2 === abc   //false</span><br><span class="line">typeof str1 // string</span><br><span class="line">typeof str2 // object</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String() 和 字面量的方式返回的都是基本类型，String() 用来做类型转换<br>  而new String()返回object</p>
</blockquote>
<p><strong>Q:为什么 ‘kimi’基本类型可以去调用length或者toString方法和属性呢？</strong></p>
<blockquote>
<p> 在这里，只要引用了字符串’kimi’的属性或方法，<strong>JavaScript就会将字符串值通过调用new String（s）的方式转换成对象，这个对象继承了字符串的方法，并用来处理属性的作用。一旦属性引用结束，这个新创建的对象就会销毁</strong>（其实在实现上并不一定创建和销毁这个临时对象，然而整个过程看起来就是这样的）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类似代码：</span><br><span class="line">var a1 = new String(&quot;kimi&quot;);</span><br><span class="line">var a2 = a1.substring(0);</span><br><span class="line">a1 = null;</span><br><span class="line">console.log(a2);  // kimi</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>存取字符串，数字或布尔值的属性时创建的临时对象称作包装对象</strong><br>同字符串一样，数字和布尔值也具有各自的方法：通过Number和Boolean构造函数创建一个临时对象，这些方法的调用均是来自这个临时对象.null和undefined没有包装对象：访问它们的属性会造成一个错误。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = “test”;</span><br><span class="line">s.len = 4; </span><br><span class="line">console.log(s.len); // undefined</span><br><span class="line">// 由于包装对象使用完毕会自己销毁，所以添加的属性也读取不到。</span><br></pre></td></tr></table></figure>

<p><strong>Q:为什么2.toString()会报错？</strong></p>
<blockquote>
<p>在这里的 . 它既可以理解为小数点，也可以理解为对方法的调用，按照规范，解释器把它判断为一个小数点。 2.toString() 在解释器看来其实是：(2.)toString();<br>如果想解决可以使用如下方式都可以正确输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2..toString()</span><br><span class="line">(2).toString();</span><br><span class="line">2 .toString();  //加个空格</span><br><span class="line">2.0.toString();</span><br></pre></td></tr></table></figure>

<h2 id="3-准确类型判断方法"><a href="#3-准确类型判断方法" class="headerlink" title="3 准确类型判断方法"></a>3 准确类型判断方法</h2><h3 id="1-instanceof-配合-typeof"><a href="#1-instanceof-配合-typeof" class="headerlink" title="1. instanceof 配合 typeof"></a>1. instanceof 配合 typeof</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Person = function() &#123;&#125;</span><br><span class="line">const p1 = new Person()</span><br><span class="line">p1 instanceof Person</span><br><span class="line"></span><br><span class="line">let str = &apos;hello&apos;</span><br><span class="line">str instanceof String // false</span><br><span class="line">str.__proto__ // String</span><br><span class="line">// str字面量有__proto__属性是因为转换成包装对象。但是本身是个基本类型，使用不了instanceof</span><br><span class="line"></span><br><span class="line">let str1 = new String(&apos;hello&apos;)</span><br><span class="line">str1 instanceof String // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上如果是基本类型可以使用typeof，引用类型使用instanceof</p>
</blockquote>
<h4 id="2-Object-prototype-toString-call"><a href="#2-Object-prototype-toString-call" class="headerlink" title="2. Object.prototype.toString.call()"></a>2. Object.prototype.toString.call()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2) // [object Number]</span><br><span class="line">Object.prototype.toString.call(&apos;kimi&apos;) // [object String]</span><br><span class="line">Object.prototype.toString.call(true) // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(Symbol(&apos;kimi&apos;)) // [object Symbol]</span><br><span class="line">Object.prototype.toString.call(new Date()) // [object Date]</span><br><span class="line">Object.prototype.toString.call(new RegExp()) // [object RegExp]</span><br></pre></td></tr></table></figure>

<p><strong>Object.prototype.toString.call()、toString()、 toString.call()</strong></p>
<blockquote>
<p>所有的对象最后都会继承Object.prototype.toString这个方法。而在每个子类中都会改写这个方法。Array、Function的原型上都已经改写了这个方法。每个对象上调用toString方法时会先调用自身的toString方法，如果找不到会沿着原型链往上找，如果一直没找到最终会找到Object.prototype.toString这个方法</p>
</blockquote>
<p><strong>具体看下每个对象调用toString方法的结果：</strong><br>1 对象 object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1&#125;;</span><br><span class="line">obj.toString(); // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(obj); // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Object.prototype.toString()  在toString方法被调用时,会执行下面的操作步骤</p>
<ol>
<li>获取this对象的[[Class]]属性的值。</li>
<li>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串。  </li>
<li>返回第二步的操作结果Result(2)。<br>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的: <strong>内部属性 描述 [[Class]] 一个字符串值,表明了该对象的类型。</strong><blockquote>
<p>其过程简单说来就是：<strong>1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</strong></p>
</blockquote>
</li>
</ol>
</blockquote>
<p>那么同时我们可以想是否任何对象object都可以通过this绑定调用Object.prototype.toString()方法，这样可以准确的检测出类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&#123;&#125;); // [object Object]</span><br><span class="line">Object.prototype.toString.call([]); // [object Array]</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;); // [object Function]</span><br><span class="line">Object.prototype.toString.call(&apos;&apos;); // [object String]</span><br><span class="line">Object.prototype.toString.call(1); // [object Number]</span><br><span class="line">Object.prototype.toString.call(true); // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(null); // [object Null]</span><br><span class="line">Object.prototype.toString.call(undefined); // [object Undefined]</span><br><span class="line">// 相当于Object.prototype.toString.call(undefined);</span><br><span class="line">Object.prototype.toString.call(); // [object Undefined] </span><br><span class="line">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class="line">Object.prototype.toString.call(/at/); // [object RegExp]</span><br><span class="line"></span><br><span class="line">// toString() 方法能识别以下类型是因为引擎为它们设置好了 toStringTag 标签</span><br><span class="line">Object.prototype.toString.call(new Map());       // &quot;[object Map]&quot;</span><br><span class="line">Object.prototype.toString.call(function* () &#123;&#125;); // &quot;[object GeneratorFunction]&quot;</span><br><span class="line">Object.prototype.toString.call(Promise.resolve()); // &quot;[object Promise]&quot;</span><br><span class="line"></span><br><span class="line">// 自己创建的类不能识别，toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="line">class ValidatorClass &#123;&#125;</span><br><span class="line">Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Object]&quot;</span><br><span class="line">// 可以加上 toStringTag 属性让他识别</span><br><span class="line">class ValidatorClass &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    return &quot;Validator&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Validator]&quot;</span><br></pre></td></tr></table></figure>

<p><strong>因为Object是所有子类的父类，所以任何类型的对象object都可以通过this绑定调用Object.prototype.toString()方法，返回该对象的字符串表示</strong></p>
<p>2 数组 array<br>toString()：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果是多维数组会递归调用toString()方法</span><br><span class="line">var array = [1, &apos;s&apos;, true, &#123;a: 2&#125;];</span><br><span class="line">array.toString();//&quot;1,s,true,[object Object]&quot;</span><br><span class="line">Array.prototype.toString.call(array);//&quot;1,s,true,[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p>那么别的对象是否可以调用数组的toString方法呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.toString.call(&#123;&#125;); // [object Object]</span><br><span class="line">Array.prototype.toString.call(function()&#123;&#125;) // [object Function]</span><br><span class="line">Array.prototype.toString.call(1) // [object Number]</span><br><span class="line">Array.prototype.toString.call(&apos;&apos;) // [object String]</span><br><span class="line">Array.prototype.toString.call(true) // [object Boolean]</span><br><span class="line">Array.prototype.toString.call(/s/) // [object RegExp]</span><br><span class="line">// 特殊</span><br><span class="line">&lt;!--以下都是 Cannot convert undefined or null to object at toString--&gt;</span><br><span class="line">Array.prototype.toString.call(); // 相当于Array.prototype.toString.call(undefined)</span><br><span class="line">Array.prototype.toString.call(undefined);</span><br><span class="line">Array.prototype.toString.call(null);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组对象通过this绑定调用Array.prototype.toString()方法，返回数组值的字符串拼接<br>非数组对象通过this绑定调用Array.prototype.toString()方法，返回的是该对象的字符串表示<br>另外null和undefined不可以通过绑定调用Array.prototype.toString()方法。</p>
</blockquote>
<p>3 函数 function<br>toString()：返回函数的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&apos;function&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">foo.toString();</span><br><span class="line">&lt;!--&quot;function foo()&#123;--&gt;</span><br><span class="line">&lt;!--    console.log(&apos;function&apos;);--&gt;</span><br><span class="line">&lt;!--&#125;&quot;--&gt;</span><br><span class="line">Function.prototype.toString.call(foo);</span><br><span class="line">&lt;!--&quot;function foo()&#123;--&gt;</span><br><span class="line">&lt;!--    console.log(&apos;function&apos;);--&gt;</span><br><span class="line">&lt;!--&#125;&quot;--&gt;</span><br><span class="line"></span><br><span class="line">// Object Function Array本质都是构造函数</span><br><span class="line">Object.toString();</span><br><span class="line">// &quot;function Object() &#123; [native code] &#125;&quot;</span><br><span class="line">Function.toString();</span><br><span class="line">// &quot;function Function() &#123; [native code] &#125;&quot;</span><br><span class="line">Array.toString();</span><br><span class="line">// &quot;function Array() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>非函数对象是否可以使用函数的toString方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.toString.call(&#123;&#125;)</span><br><span class="line">&lt;!--Function.prototype.toString requires that &apos;this&apos; be a Function--&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了上述提到的Object和Array两种情况，其他类型都不支持非自身实例通过this绑定调用该Object子类原型对象上的toString()方法，这说明它们在重写toString()方法时，明确限定了调用该方法的对象类型，非自身对象实例不可调用。所以，<strong>一般我们只使用Object.prototype.toString.call/apply()方法。</strong></p>
</blockquote>
<p>4 日期 Date<br>toString()：返回带有时区信息的日期和时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">date.toString();</span><br><span class="line">//&quot;Fri May 11 2019 14:55:43 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">Date.prototype.toString.call(date);</span><br><span class="line">//&quot;Fri May 11 2019 14:55:43 GMT+0800 (中国标准时间)&quot;</span><br></pre></td></tr></table></figure>

<p>5 正则 RegExp<br>toString()：返回正则表达式的字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var re = /cat/g;</span><br><span class="line">re.toString();// &quot;/cat/g&quot;</span><br><span class="line">RegExp.prototype.toString.call(re);// &quot;/cat/g&quot;</span><br></pre></td></tr></table></figure>

<p>6 字符串 string<br>toString()：返回字符串的一个副本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;a&quot;;</span><br><span class="line">str.toString(); //&quot;a&quot;</span><br><span class="line">String.prototype.toString.call(str); //&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>7 数字 number<br>toString()：返回字符串形式的数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num = 520;</span><br><span class="line">num.toString(); //&quot;520&quot;</span><br><span class="line">Number.prototype.toString.call(num); //&quot;520&quot;</span><br></pre></td></tr></table></figure>

<p>8 布尔 boolean<br>toString()：返回字符串”true”或”false”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var boo = true;</span><br><span class="line">boo.toString(); //&quot;true&quot;</span><br><span class="line">Boolean.prototype.toString.call(boo); //&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p>9 null和undefined</p>
<blockquote>
<p>null和undefined没有相应的构造函数，所以它们没有也无法调用toString()方法，也就是说它们不能访问任何属性和方法，只是基本类型而已。</p>
</blockquote>
<p>10 全局对象window（Window类）<br>toString(): 返回对象的字符串表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.toString();</span><br><span class="line">&lt;!--&quot;[object Window]&quot;--&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Winodw类并没有在Window.prototype原型对象上重写toString()方法，它会顺着原型链查找调用Object.prototype.toString()。<br>所以上述代码为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(window);</span><br><span class="line">&lt;!--&quot;[object Window]&quot;--&gt;</span><br></pre></td></tr></table></figure>

<p><strong>toString.call()</strong><br> toString.call()和toString()直接调用一样都返回[object Undefined],</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toString.call() // [object Undefined]</span><br><span class="line">toString() // [object Undefined]</span><br><span class="line">window.toString.call() // [object Undefined]</span><br><span class="line">window.toString.call(undefined) // [object Undefined]</span><br><span class="line">Object.prototype.toString.call() // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(undefined) // [object Undefined]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以toString.call()相当于<br>window.toString.call()  -&gt; window.toString.call(undefined) -&gt; Object.prototype.toString.call()  -&gt;Object.prototype.toString.call(undefined)</p>
</blockquote>
<p><strong>所以用Object.prototype.toString.call() 判断类型可以简写为toString.call()来判断</strong><br>  但是要注意如果已经有定义了toString函数就不可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toString()&#123;</span><br><span class="line">    console.log(&quot;kimi&quot;)</span><br><span class="line">&#125;</span><br><span class="line">toString(); //&quot;kimi&quot;</span><br><span class="line">toString.call(&#123;&#125;); //&quot;kimi&quot;</span><br><span class="line">toString.call([]); //&quot;kimi&quot;</span><br></pre></td></tr></table></figure>


    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持superkimi</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="hide pull-left" href="/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/07/21/js_type_tranform/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
