[{"title":"javascript基础-跨域和解决跨域的方法","url":"/2019/07/26/js_cors/","content":"<h1 id=\"js跨域\"><a href=\"#js跨域\" class=\"headerlink\" title=\"js跨域\"></a>js跨域</h1><h2 id=\"1-同源策略\"><a href=\"#1-同源策略\" class=\"headerlink\" title=\"1.同源策略\"></a>1.同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>\n<p>同源策略限制内容有：<br>Cookie、LocalStorage、IndexedDB 等存储性内容<br>DOM 节点<br>AJAX 请求发送后，结果被浏览器拦截了</p>\n<p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>\n<h2 id=\"2-常见跨域场景\"><a href=\"#2-常见跨域场景\" class=\"headerlink\" title=\"2.常见跨域场景\"></a>2.常见跨域场景</h2><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p>\n<p><img src=\"/images/cors.png\" alt=\"cors.png\"></p>\n<h2 id=\"3-实现跨域的九种方式\"><a href=\"#3-实现跨域的九种方式\" class=\"headerlink\" title=\"3. 实现跨域的九种方式\"></a>3. 实现跨域的九种方式</h2><h3 id=\"1-gt-jsonp\"><a href=\"#1-gt-jsonp\" class=\"headerlink\" title=\"1&gt; jsonp\"></a>1&gt; jsonp</h3><p>有几个标签是允许跨域加载资源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=XXX&gt;</span><br><span class=\"line\">&lt;link href=XXX&gt;</span><br><span class=\"line\">&lt;script src=XXX&gt;</span><br><span class=\"line\">&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链</span><br></pre></td></tr></table></figure>\n\n<p><strong>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击（jsonp请求返回<script></script>）。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">   function kimi(data) &#123;</span><br><span class=\"line\">     console.log(data)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &lt;/script&gt;</span><br><span class=\"line\"> &lt;script src=&quot;https://www.baidu.com/sugrec?prod=pc&amp;wd=8&amp;cb=kimi&quot;&gt;</span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-gt-cors\"><a href=\"#2-gt-cors\" class=\"headerlink\" title=\"2&gt; cors\"></a>2&gt; cors</h3><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n<p>服务端设置了Access-Control-Allow-Origin就开启了CORS通信，表示允许哪个域来访问我。<br>具体需要设置的头部有很多，列举常用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置哪个源可以访问我</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Origin&apos;, origin)</span><br><span class=\"line\">// 允许携带哪个头访问我</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;name&apos;)</span><br><span class=\"line\">// 允许哪个方法访问我</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;)</span><br><span class=\"line\">// 允许携带cookie</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true)</span><br><span class=\"line\">// 预检的存活时间</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Max-Age&apos;, 6)</span><br><span class=\"line\">// 允许返回的头</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-gt-postMessage\"><a href=\"#3-gt-postMessage\" class=\"headerlink\" title=\"3&gt; postMessage\"></a>3&gt; postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>页面和其打开的新窗口的数据传递</li>\n<li>多窗口之间消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html</span><br><span class=\"line\">  &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      function load() &#123;</span><br><span class=\"line\">        let frame = document.getElementById(&apos;frame&apos;)</span><br><span class=\"line\">        frame.contentWindow.postMessage(&apos;kimi&apos;, &apos;http://localhost:4000&apos;) //发送数据</span><br><span class=\"line\">        window.onmessage = function(e) &#123; //接受返回数据</span><br><span class=\"line\">          console.log(e.data) //yes</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b.html</span><br><span class=\"line\">  window.onmessage = function(e) &#123;</span><br><span class=\"line\">    console.log(e.data) //kimi</span><br><span class=\"line\">    e.source.postMessage(&apos;yes, e.origin)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-gt-http-proxy\"><a href=\"#4-gt-http-proxy\" class=\"headerlink\" title=\"4&gt; http-proxy\"></a>4&gt; http-proxy</h3><p>  一般在使用webpack时webpack-dev-server会加proxy-table来转发请求。因为同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略</p>\n<h3 id=\"5-gt-nginx\"><a href=\"#5-gt-nginx\" class=\"headerlink\" title=\"5&gt; nginx\"></a>5&gt; nginx</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  nginx proxy服务器</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       81;</span><br><span class=\"line\">    server_name  www.domain1.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class=\"line\">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-gt-websocket\"><a href=\"#6-gt-websocket\" class=\"headerlink\" title=\"6&gt; websocket\"></a>6&gt; websocket</h3><p>websocket 是没有跨域限制的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// socket.html</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let socket = new WebSocket(&apos;ws://localhost:3000&apos;);</span><br><span class=\"line\">    socket.onopen = function () &#123;</span><br><span class=\"line\">      socket.send(&apos;kimi1&apos;);//向服务器发送数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    socket.onmessage = function (e) &#123;</span><br><span class=\"line\">      console.log(e.data);//接收服务器返回的数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// server.js</span><br><span class=\"line\">let express = require(&apos;express&apos;);</span><br><span class=\"line\">let app = express();</span><br><span class=\"line\">let WebSocket = require(&apos;ws&apos;);</span><br><span class=\"line\">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class=\"line\">wss.on(&apos;connection&apos;,function(ws) &#123;</span><br><span class=\"line\">  ws.on(&apos;message&apos;, function (data) &#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">    ws.send(&apos;kimi2&apos;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-gt-document-domain\"><a href=\"#7-gt-document-domain\" class=\"headerlink\" title=\"7&gt; document.domain\"></a>7&gt; document.domain</h3><p>该方式只能用于二级域名相同的情况下，比如 video.baidu.com 和 <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 适用于该方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"> helloa</span><br><span class=\"line\">  &lt;iframe src=&quot;http://video.baidu.com&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    document.domain = &apos;baidu.cn&apos;</span><br><span class=\"line\">    function load() &#123;</span><br><span class=\"line\">      console.log(frame.contentWindow.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b.html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">   hellob</span><br><span class=\"line\">   &lt;script&gt;</span><br><span class=\"line\">     document.domain = &apos;baidu.cn&apos;</span><br><span class=\"line\">     var a = 100;</span><br><span class=\"line\">   &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-gt-window-name\"><a href=\"#8-gt-window-name\" class=\"headerlink\" title=\"8&gt; window.name\"></a>8&gt; window.name</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<blockquote>\n<p>实现：先在a页面中嵌入c页面，在c页面中写入window.name值, c加载完毕后马上切换成a同源的b页面。等b加载完后可以拿到没有清除的name值</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html(http://localhost:3000/b.html)</span><br><span class=\"line\">  &lt;iframe src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    let first = true</span><br><span class=\"line\">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class=\"line\">    function load() &#123;</span><br><span class=\"line\">      if(first)&#123;</span><br><span class=\"line\">      // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class=\"line\">        let iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class=\"line\">        iframe.src = &apos;http://localhost:3000/b.html&apos;;</span><br><span class=\"line\">        first = false;</span><br><span class=\"line\">      &#125;else&#123;</span><br><span class=\"line\">      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span><br><span class=\"line\">        console.log(iframe.contentWindow.name);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// c.html(http://localhost:4000/c.html)</span><br><span class=\"line\"> &lt;script&gt;</span><br><span class=\"line\">   window.name = &apos;yes&apos;  </span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-gt-location-hash\"><a href=\"#9-gt-location-hash\" class=\"headerlink\" title=\"9&gt; location.hash\"></a>9&gt; location.hash</h3><blockquote>\n<p>a页面嵌入c页面带给他hash数据，c页面中拿到后，再嵌入和a同源的b页面带入hash数据，b拿到后再设置回a页面的hash中。a中再监听hash变化来获取。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html</span><br><span class=\"line\">  &lt;iframe src=&quot;http://localhost:4000/c.html#kimi&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    window.onhashchange = function () &#123; //检测hash的变化</span><br><span class=\"line\">      console.log(location.hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b.html</span><br><span class=\"line\"> &lt;script&gt;</span><br><span class=\"line\">   window.parent.parent.location.hash = location.hash </span><br><span class=\"line\">   //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// c.html</span><br><span class=\"line\">console.log(location.hash);</span><br><span class=\"line\"> let iframe = document.createElement(&apos;iframe&apos;);</span><br><span class=\"line\"> iframe.src = &apos;http://localhost:3000/b.html#yes&apos;;</span><br><span class=\"line\"> document.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>现在业界主流使用解决跨域问题的方案主要是 nginx和cors、jsonp（优势在于可以兼容老版本浏览器，但是只支持get并且不安全），本地开发常用node-proxy的方式做反向代理。其他的方式都不常用。location.hash和window.name都需要有第三方中介。而domain的方式会有域名的限制条件。</p>\n</blockquote>\n","categories":["前端技术"],"tags":["javascript"]},{"title":"javascript基础-类型转换","url":"/2019/07/21/js_type_tranform/","content":"<h1 id=\"js类型转换\"><a href=\"#js类型转换\" class=\"headerlink\" title=\"js类型转换\"></a>js类型转换</h1><h2 id=\"1-用于类型转换的valueOf和toString\"><a href=\"#1-用于类型转换的valueOf和toString\" class=\"headerlink\" title=\"1 用于类型转换的valueOf和toString\"></a>1 用于类型转换的valueOf和toString</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\" target=\"_blank\" rel=\"noopener\">valueOf()</a>的意义是，返回这个对象<strong>逻辑上对应的</strong>原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\" target=\"_blank\" rel=\"noopener\">toString()</a>的意义是，返回这个对象的字符串表示。<strong>用一个字符串来描述这个对象的内容。</strong></li>\n</ul>\n<p><strong>基本类型的valueOf会返回自身的原始类型，而Array、Function、Object都返回自身，Date返回时间戳，Error和Math没有valueOf方法</strong></p>\n<h2 id=\"2-用于检测类型的四个js内部方法\"><a href=\"#2-用于检测类型的四个js内部方法\" class=\"headerlink\" title=\"2 用于检测类型的四个js内部方法\"></a>2 用于检测类型的四个js内部方法</h2><p>这4个方法实际上是<a href=\"https://tc39.github.io/ecma262/#sec-type-conversion\" target=\"_blank\" rel=\"noopener\">ECMAScript定义的4个抽象的操作</a>，它们在js内部使用，进行类型转换。我们js的使用者不能直接调用这些函数，但是了解这些函数有利于我们理解js类型转换的原理。</p>\n<ul>\n<li>ToPrimitive ( input [ , PreferredType ] )</li>\n<li>ToBoolean ( argument )</li>\n<li>ToNumber ( argument )</li>\n<li>ToString ( argument )</li>\n</ul>\n<blockquote>\n<p>请区分这里的ToString()和上文谈到的toString()，一个是js引擎内部使用的函数，另一个是定义在对象上的函数。</p>\n</blockquote>\n<h3 id=\"ToPrimitive-input-PreferredType\"><a href=\"#ToPrimitive-input-PreferredType\" class=\"headerlink\" title=\"ToPrimitive ( input [ , PreferredType ] )\"></a>ToPrimitive ( input [ , PreferredType ] )</h3><p>将input转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number 或 String。<strong>如果PreferredType参数是Number</strong>，ToPrimitive这样执行：</p>\n<ol>\n<li>如果input本身就是原始类型，直接返回input。</li>\n<li>调用<strong>input.valueOf()</strong>，如果结果是原始类型，则返回这个结果。</li>\n<li>调用<strong>input.toString()</strong>，如果结果是原始类型，则返回这个结果。</li>\n<li>抛出TypeError异常。</li>\n</ol>\n<p><strong>以下是PreferredType不为Number时的执行顺序。</strong></p>\n<ul>\n<li>如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。</li>\n<li>如果PreferredType参数没有传入<ul>\n<li>如果input是内置的Date类型，PreferredType 视为String</li>\n<li>否则PreferredType 视为 Number – 先调用valueOf 再调用toString</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Date 转换的时候PreferredType 视为String先调用toString。所以console.log(111 + new Date())  // “111Thu Jul 25 2019 22:34:51 GMT+0800 (中国标准时间)”</p>\n</blockquote>\n<blockquote>\n<p><strong>可以看出，ToPrimitive依赖于valueOf和toString的实现。</strong><br><img src=\"/images/to.jpg\" alt=\"toPrimitive.jpg\"></p>\n</blockquote>\n<h3 id=\"ToBoolean-argument\"><a href=\"#ToBoolean-argument\" class=\"headerlink\" title=\"ToBoolean ( argument )\"></a>ToBoolean ( argument )</h3><table>\n<thead>\n<tr>\n<th>Argument Type</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>Return false</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Return false</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>Return argument</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>仅当argument为 +0, -0, or NaN时， return false; 否则一律 return true</td>\n</tr>\n<tr>\n<td>String</td>\n<td>仅当argument是空字符串（长度为0）时， return false; 否则一律 return true</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>Return true</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>Return true</td>\n</tr>\n</tbody></table>\n<p>这些规定都来自<a href=\"https://tc39.github.io/ecma262/#sec-toboolean\" target=\"_blank\" rel=\"noopener\">ECMA的标准</a>，在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。</p>\n<h3 id=\"ToNumber-argument\"><a href=\"#ToNumber-argument\" class=\"headerlink\" title=\"ToNumber ( argument )\"></a>ToNumber ( argument )</h3><table>\n<thead>\n<tr>\n<th>Argument Type</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>Return NaN</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Return +0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果 argument 为 true, return 1. 如果 argument 为 false, return +0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>直接返回argument</td>\n</tr>\n<tr>\n<td>String</td>\n<td>将字符串中的内容转化为数字（比如”23”-&gt;23），如果转化失败则返回NaN（比如”23a”-&gt;NaN）</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>抛出 TypeError 异常</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>先<strong>primValue = ToPrimitive(argument, Number)</strong>，再对primValue 使用 ToNumber(primValue)</td>\n</tr>\n</tbody></table>\n<p>由上表可见ToNumber的转化并不总是成功，有时会转化成NaN，有时则直接抛出异常。</p>\n<blockquote>\n<p>所以Number([1,2]) -&gt; 先由ToPrimitive(argument, Number)转换[1,2]  -&gt; valueOf返回本身，再调用toString返回’1,2’ -&gt; 再ToNumber(primValue) 转换为NaN</p>\n</blockquote>\n<h3 id=\"ToString-argument\"><a href=\"#ToString-argument\" class=\"headerlink\" title=\"ToString ( argument )\"></a>ToString ( argument )</h3><table>\n<thead>\n<tr>\n<th>Argument Type</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>Return “undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Return “null”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果 argument 为 true, return “true”.如果 argument 为 false, return “false”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>用字符串来表示这个数字</td>\n</tr>\n<tr>\n<td>String</td>\n<td>直接返回 argument</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>抛出 TypeError 异常</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>先primValue = ToPrimitive(argument, hint String)，再对primValue使用ToString(primValue)</td>\n</tr>\n</tbody></table>\n<p><img src=\"/images/tra.png\" alt=\"2.png\"></p>\n<h2 id=\"3-隐式类型转换（自动类型转换）\"><a href=\"#3-隐式类型转换（自动类型转换）\" class=\"headerlink\" title=\"3 隐式类型转换（自动类型转换）\"></a>3 隐式类型转换（自动类型转换）</h2><p>当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。</p>\n<p>例子1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ( !undefined</span><br><span class=\"line\">  &amp;&amp; !null</span><br><span class=\"line\">  &amp;&amp; !0</span><br><span class=\"line\">  &amp;&amp; !NaN</span><br><span class=\"line\">  &amp;&amp; !&apos;&apos;</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // true</span><br></pre></td></tr></table></figure>\n\n<p>例子1：因为在if的括号中，js期望得到boolean的值，所以对括号中每一个值都使用ToBoolean ( argument )，将它们转化成boolean。</p>\n<p>例子2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 * &#123; valueOf: function () &#123; return 5 &#125; &#125;;  //15</span><br></pre></td></tr></table></figure>\n\n<p>例子2：因为在乘号的两端，js期望得到number类型的值，所以对右边的那个对象使用ToNumber ( argument )，得到结果5，再与乘号左边的3相乘。</p>\n<p>例子3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; function returnObject() &#123; return &#123;&#125; &#125;</span><br><span class=\"line\">&gt; 3 * &#123; valueOf: function () &#123; return &#123;&#125; &#125;, toString: function () &#123; return &#123;&#125; &#125; &#125;</span><br><span class=\"line\">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>\n\n<p>例子3：调用ToNumber ( argument )的过程中，调用了ToPrimitive ( input , Number )，因为在ToPrimitive中valueOf和toString都没有返回原始类型，所以抛出异常。</p>\n<h3 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h3><p>符号’+’是一个比较棘手的一个符号，因为它既可以表示“算数加法”，也可以表示“字符串拼接”。<br>简单理解版本：只要’+’两端的任意一个操作数是字符串，那么这个’+’就表示字符串拼接，否则表示算数加法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12+3</span><br><span class=\"line\">// 15</span><br><span class=\"line\">12+&apos;3&apos;</span><br><span class=\"line\">// &quot;123&quot;</span><br></pre></td></tr></table></figure>\n\n<p>原理理解版本：根据<a href=\"https://tc39.github.io/ecma262/#sec-addition-operator-plus\" target=\"_blank\" rel=\"noopener\">ECMAScript的定义</a>，对’+’运算的求值按照以下过程：</p>\n<ol>\n<li>令lval = 符号左边的值，rval = 符号右边的值</li>\n<li>令lprim = ToPrimitive(lval)，rprim = ToPrimitive(rval)</li>\n<li><ul>\n<li>如果lprim和rprim中<strong>有任意一个为string类型</strong>，将ToString(lprim)和ToString(rprim)的结果做字符串拼接</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>否则，将ToNumber(lprim)和ToNumber(rprim)的结果做算数加法</li>\n</ul>\n<p>根据这个原理可以解释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]+[]</span><br><span class=\"line\">//  &quot;&quot;</span><br><span class=\"line\">// 提示：ToPrimitive([])返回空字符串</span><br><span class=\"line\"></span><br><span class=\"line\">[] + &#123;&#125;</span><br><span class=\"line\">//  &quot;[object Object]&quot;</span><br><span class=\"line\">//  提示：ToPrimitive(&#123;&#125;)返回&quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">123 + &#123; toString: function () &#123; return &quot;def&quot; &#125; &#125;</span><br><span class=\"line\">//  &quot;123def&quot;</span><br><span class=\"line\">//  提示：ToPrimitive(加号右边的对象)返回&quot;def&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#125; + []</span><br><span class=\"line\">//  0</span><br><span class=\"line\">// 结果不符合我们的预期：&quot;[object Object]&quot;</span><br><span class=\"line\">// 提示：在Chrome中，符号左边的&#123;&#125;被解释成了一个语句块，而不是一个对象</span><br><span class=\"line\">// 注意在别的执行引擎上可能会将&#123;&#125;解释成对象</span><br><span class=\"line\">//  这一行等价于&apos;+[]&apos;</span><br><span class=\"line\">// &apos;+anyValue&apos;等价于Number(anyValue)</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123;&#125;) + []</span><br><span class=\"line\">//  &quot;[object Object]&quot;</span><br><span class=\"line\">// 加上括号以后，&#123;&#125;被解释成了一个对象，结果符合我们的预期了</span><br></pre></td></tr></table></figure>\n\n<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;a&apos; + + &apos;b&apos; // -&gt; &quot;aNaN&quot;</span><br></pre></td></tr></table></figure>\n\n<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。相当于调用ToNumber方法</p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><ol>\n<li>如果是对象，就通过 toPrimitive 转换对象</li>\n<li>如果是字符串，就通过 unicode 字符索引来比较<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  valueOf() &#123;</span><br><span class=\"line\">    return 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;1&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a &gt; -1 // true</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"双等\"><a href=\"#双等\" class=\"headerlink\" title=\"== 双等\"></a>== 双等</h3><blockquote>\n<p>xy都为Null或undefined,return true; 一方为Null或undefined，return false<br>x或y为NaN, return false;<br>如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较<br>如果存在Object，转换为原始值，再比较</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;0&quot; == null; // false</span><br><span class=\"line\">&quot;0&quot; == undefined; // false</span><br><span class=\"line\">&quot;0&quot; == false; // true ！</span><br><span class=\"line\">&quot;0&quot; == NaN; // false</span><br><span class=\"line\">&quot;0&quot; == 0; // true</span><br><span class=\"line\">&quot;0&quot; == &quot;&quot;; // false</span><br><span class=\"line\">false == null; // false</span><br><span class=\"line\">false == undefined; // false</span><br><span class=\"line\">false == NaN; // false</span><br><span class=\"line\">false == 0; // true ！</span><br><span class=\"line\">false == &quot;&quot;; // true ！</span><br><span class=\"line\">false == []; // true ！</span><br><span class=\"line\">false == &#123;&#125;; // false</span><br><span class=\"line\">&quot;&quot; == null; // false</span><br><span class=\"line\">&quot;&quot; == undefined; // false</span><br><span class=\"line\">&quot;&quot; == NaN; // false</span><br><span class=\"line\">&quot;&quot; == 0; // true ！</span><br><span class=\"line\">&quot;&quot; == []; // true ！</span><br><span class=\"line\">&quot;&quot; == &#123;&#125;; // false</span><br><span class=\"line\">0 == null; // false</span><br><span class=\"line\">0 == undefined; // false</span><br><span class=\"line\">0 == NaN; // false</span><br><span class=\"line\">0 == []; // true ！</span><br><span class=\"line\">0 == &#123;&#125;; // false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-显式类型转换（强制类型转换）\"><a href=\"#4-显式类型转换（强制类型转换）\" class=\"headerlink\" title=\"4 显式类型转换（强制类型转换）\"></a>4 显式类型转换（强制类型转换）</h2><p>程序员显式调用Boolean(value)、Number(value)、String(value)完成的类型转换，叫做显示类型转换。<br>我们在文章的前面说过new Boolean(value)、new Number(value)、new String(value)传入各自对应的原始类型的值，可以实现“装箱”——将原始类型封装成一个对象。其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean(&apos;sdfsd&apos;);  //  true</span><br><span class=\"line\">Number(&quot;23&quot;);  //  23</span><br><span class=\"line\">String(&#123;a:24&#125;);  //  &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n<p>其实这三个函数用于类型转换的时候，调用的就是js内部的<code>ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )</code>方法！<br>Number()比parseInt parseFloat严格。parseInt parseFloat会只截取数字转换</p>\n<p>这里解释一下<code>String({a:24}); // &quot;[object Object]&quot;</code>的过程：</p>\n<ul>\n<li>执行String({a:24})<ul>\n<li>执行js内部函数ToString ( {a:24} )<ul>\n<li>执行<code>primValue = ToPrimitive({a:24}, hint String)</code><ol>\n<li>因为{a:24}不是原始类型，进入下一步。</li>\n<li>在ToPrimitive内调用({a:24}).toString()，返回了原始值”[object Object]”，因此直接返回这个字符串，ToPrimitive后面的步骤不用进行下去了。</li>\n</ol>\n</li>\n<li>primValue被赋值为ToPrimitive的返回值：”[object Object]”</li>\n<li>执行js内部函数ToString ( “[object Object]” )，返回”[object Object]”</li>\n<li>返回”[object Object]”</li>\n</ul>\n</li>\n<li>返回”[object Object]”</li>\n</ul>\n</li>\n<li>返回”[object Object]”</li>\n</ul>\n<blockquote>\n<p>为了防止出现意料之外的结果，<strong>最好在不确定的地方使用显式类型转换</strong>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">\tvalueOf() &#123;</span><br><span class=\"line\">\t\treturn 2</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttoString()&#123;</span><br><span class=\"line\">\t\treturn []</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">String(obj2)  // &apos;2&apos;</span><br><span class=\"line\">2 + obj2   // 4</span><br></pre></td></tr></table></figure>\n\n<p>当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  valueOf() &#123;</span><br><span class=\"line\">    return 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;1&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  [Symbol.toPrimitive]() &#123;</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">1 + a // =&gt; 3</span><br></pre></td></tr></table></figure>\n\n","categories":["前端技术"],"tags":["javascript"]},{"title":"javascript基础-数据类型","url":"/2019/07/21/js_type/","content":"<h1 id=\"js-数据类型\"><a href=\"#js-数据类型\" class=\"headerlink\" title=\"js 数据类型\"></a>js 数据类型</h1><p>  js中有六种原始类型：</p>\n<ul>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>string</li>\n<li>symbol<br>一种引用类型</li>\n<li>object</li>\n</ul>\n<p>引用类型和基本类型有什么区别，以及深浅拷贝之类就暂时不表了。</p>\n<h2 id=\"1-typeof\"><a href=\"#1-typeof\" class=\"headerlink\" title=\"1 typeof\"></a>1 typeof</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof false // boolean</span><br><span class=\"line\">typeof null // object</span><br><span class=\"line\">typeof undefined // undefined</span><br><span class=\"line\">typeof 2 // number</span><br><span class=\"line\">typeof NaN // number</span><br><span class=\"line\">typeof Infinity // number</span><br><span class=\"line\">typeof &apos;kimi&apos; // string</span><br><span class=\"line\">typeof Symbol(&apos;kimi&apos;) // symbol</span><br><span class=\"line\"></span><br><span class=\"line\">typeof Date // funtion</span><br><span class=\"line\">typeof [2,2,3] // object</span><br><span class=\"line\">typeof &#123;a:1&#125; // object</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>使用typeof检测基本类型基本可以正确的判断出类型的，但是判断引用类型时就没有那么准确了。因为数组、对象、函数实际上都是引用类型。但function对象和普通的对象相比，其内部有一个<strong>[[call]]</strong>方法，用来表示这个对象是可调用的。所以返回时function。实际<strong>函数就是一个可调用对象。</strong>如果要准确的判断各个引用类型就需要使用<strong>instanceof</strong>。</li>\n<li>null返回object。这是js的一个bug，js最初版本使用的是32位系统，为了性能考虑用低位存储变量的类型信息，<strong>000</strong>开头表示对象，然后null为<strong>全零</strong>。所以返回object。现在内部类型判断代码已经改变。但是这个bug仍然在。<strong>所以null其实算做基本类型</strong></li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null instanceof object // false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-字面量、String-、new-String\"><a href=\"#2-字面量、String-、new-String\" class=\"headerlink\" title=\"2 字面量、String()、new String()\"></a>2 字面量、String()、new String()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var abc = &apos;abc&apos;,</span><br><span class=\"line\">    str1 = String(abc),</span><br><span class=\"line\">    str2 = new String(abc);</span><br><span class=\"line\">//判断下面输出</span><br><span class=\"line\">str1 === abc   //true</span><br><span class=\"line\">str2 === abc   //false</span><br><span class=\"line\">typeof str1 // string</span><br><span class=\"line\">typeof str2 // object</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>String() 和 字面量的方式返回的都是基本类型，String() 用来做类型转换<br>  而new String()返回object</p>\n</blockquote>\n<p><strong>Q:为什么 ‘kimi’基本类型可以去调用length或者toString方法和属性呢？</strong></p>\n<blockquote>\n<p> 在这里，只要引用了字符串’kimi’的属性或方法，<strong>JavaScript就会将字符串值通过调用new String（s）的方式转换成对象，这个对象继承了字符串的方法，并用来处理属性的作用。一旦属性引用结束，这个新创建的对象就会销毁</strong>（其实在实现上并不一定创建和销毁这个临时对象，然而整个过程看起来就是这样的）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类似代码：</span><br><span class=\"line\">var a1 = new String(&quot;kimi&quot;);</span><br><span class=\"line\">var a2 = a1.substring(0);</span><br><span class=\"line\">a1 = null;</span><br><span class=\"line\">console.log(a2);  // kimi</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>存取字符串，数字或布尔值的属性时创建的临时对象称作包装对象</strong><br>同字符串一样，数字和布尔值也具有各自的方法：通过Number和Boolean构造函数创建一个临时对象，这些方法的调用均是来自这个临时对象.null和undefined没有包装对象：访问它们的属性会造成一个错误。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = “test”;</span><br><span class=\"line\">s.len = 4; </span><br><span class=\"line\">console.log(s.len); // undefined</span><br><span class=\"line\">// 由于包装对象使用完毕会自己销毁，所以添加的属性也读取不到。</span><br></pre></td></tr></table></figure>\n\n<p><strong>Q:为什么2.toString()会报错？</strong></p>\n<blockquote>\n<p>在这里的 . 它既可以理解为小数点，也可以理解为对方法的调用，按照规范，解释器把它判断为一个小数点。 2.toString() 在解释器看来其实是：(2.)toString();<br>如果想解决可以使用如下方式都可以正确输出</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2..toString()</span><br><span class=\"line\">(2).toString();</span><br><span class=\"line\">2 .toString();  //加个空格</span><br><span class=\"line\">2.0.toString();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-准确类型判断方法\"><a href=\"#3-准确类型判断方法\" class=\"headerlink\" title=\"3 准确类型判断方法\"></a>3 准确类型判断方法</h2><h3 id=\"1-instanceof-配合-typeof\"><a href=\"#1-instanceof-配合-typeof\" class=\"headerlink\" title=\"1. instanceof 配合 typeof\"></a>1. instanceof 配合 typeof</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person = function() &#123;&#125;</span><br><span class=\"line\">const p1 = new Person()</span><br><span class=\"line\">p1 instanceof Person</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;hello&apos;</span><br><span class=\"line\">str instanceof String // false</span><br><span class=\"line\">str.__proto__ // String</span><br><span class=\"line\">// str字面量有__proto__属性是因为转换成包装对象。但是本身是个基本类型，使用不了instanceof</span><br><span class=\"line\"></span><br><span class=\"line\">let str1 = new String(&apos;hello&apos;)</span><br><span class=\"line\">str1 instanceof String // true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>综上如果是基本类型可以使用typeof，引用类型使用instanceof</p>\n</blockquote>\n<h4 id=\"2-Object-prototype-toString-call\"><a href=\"#2-Object-prototype-toString-call\" class=\"headerlink\" title=\"2. Object.prototype.toString.call()\"></a>2. Object.prototype.toString.call()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(2) // [object Number]</span><br><span class=\"line\">Object.prototype.toString.call(&apos;kimi&apos;) // [object String]</span><br><span class=\"line\">Object.prototype.toString.call(true) // [object Boolean]</span><br><span class=\"line\">Object.prototype.toString.call(Symbol(&apos;kimi&apos;)) // [object Symbol]</span><br><span class=\"line\">Object.prototype.toString.call(new Date()) // [object Date]</span><br><span class=\"line\">Object.prototype.toString.call(new RegExp()) // [object RegExp]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Object.prototype.toString.call()、toString()、 toString.call()</strong></p>\n<blockquote>\n<p>所有的对象最后都会继承Object.prototype.toString这个方法。而在每个子类中都会改写这个方法。Array、Function的原型上都已经改写了这个方法。每个对象上调用toString方法时会先调用自身的toString方法，如果找不到会沿着原型链往上找，如果一直没找到最终会找到Object.prototype.toString这个方法</p>\n</blockquote>\n<p><strong>具体看下每个对象调用toString方法的结果：</strong><br>1 对象 object</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a: 1&#125;;</span><br><span class=\"line\">obj.toString(); // &quot;[object Object]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(obj); // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Object.prototype.toString()  在toString方法被调用时,会执行下面的操作步骤</p>\n<ol>\n<li>获取this对象的[[Class]]属性的值。</li>\n<li>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串。  </li>\n<li>返回第二步的操作结果Result(2)。<br>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的: <strong>内部属性 描述 [[Class]] 一个字符串值,表明了该对象的类型。</strong><blockquote>\n<p>其过程简单说来就是：<strong>1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</strong></p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p>那么同时我们可以想是否任何对象object都可以通过this绑定调用Object.prototype.toString()方法，这样可以准确的检测出类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(&#123;&#125;); // [object Object]</span><br><span class=\"line\">Object.prototype.toString.call([]); // [object Array]</span><br><span class=\"line\">Object.prototype.toString.call(function()&#123;&#125;); // [object Function]</span><br><span class=\"line\">Object.prototype.toString.call(&apos;&apos;); // [object String]</span><br><span class=\"line\">Object.prototype.toString.call(1); // [object Number]</span><br><span class=\"line\">Object.prototype.toString.call(true); // [object Boolean]</span><br><span class=\"line\">Object.prototype.toString.call(null); // [object Null]</span><br><span class=\"line\">Object.prototype.toString.call(undefined); // [object Undefined]</span><br><span class=\"line\">// 相当于Object.prototype.toString.call(undefined);</span><br><span class=\"line\">Object.prototype.toString.call(); // [object Undefined] </span><br><span class=\"line\">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class=\"line\">Object.prototype.toString.call(/at/); // [object RegExp]</span><br><span class=\"line\"></span><br><span class=\"line\">// toString() 方法能识别以下类型是因为引擎为它们设置好了 toStringTag 标签</span><br><span class=\"line\">Object.prototype.toString.call(new Map());       // &quot;[object Map]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(function* () &#123;&#125;); // &quot;[object GeneratorFunction]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(Promise.resolve()); // &quot;[object Promise]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 自己创建的类不能识别，toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class=\"line\">class ValidatorClass &#123;&#125;</span><br><span class=\"line\">Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Object]&quot;</span><br><span class=\"line\">// 可以加上 toStringTag 属性让他识别</span><br><span class=\"line\">class ValidatorClass &#123;</span><br><span class=\"line\">  get [Symbol.toStringTag]() &#123;</span><br><span class=\"line\">    return &quot;Validator&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Validator]&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为Object是所有子类的父类，所以任何类型的对象object都可以通过this绑定调用Object.prototype.toString()方法，返回该对象的字符串表示</strong></p>\n<p>2 数组 array<br>toString()：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果是多维数组会递归调用toString()方法</span><br><span class=\"line\">var array = [1, &apos;s&apos;, true, &#123;a: 2&#125;];</span><br><span class=\"line\">array.toString();//&quot;1,s,true,[object Object]&quot;</span><br><span class=\"line\">Array.prototype.toString.call(array);//&quot;1,s,true,[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n<p>那么别的对象是否可以调用数组的toString方法呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.toString.call(&#123;&#125;); // [object Object]</span><br><span class=\"line\">Array.prototype.toString.call(function()&#123;&#125;) // [object Function]</span><br><span class=\"line\">Array.prototype.toString.call(1) // [object Number]</span><br><span class=\"line\">Array.prototype.toString.call(&apos;&apos;) // [object String]</span><br><span class=\"line\">Array.prototype.toString.call(true) // [object Boolean]</span><br><span class=\"line\">Array.prototype.toString.call(/s/) // [object RegExp]</span><br><span class=\"line\">// 特殊</span><br><span class=\"line\">&lt;!--以下都是 Cannot convert undefined or null to object at toString--&gt;</span><br><span class=\"line\">Array.prototype.toString.call(); // 相当于Array.prototype.toString.call(undefined)</span><br><span class=\"line\">Array.prototype.toString.call(undefined);</span><br><span class=\"line\">Array.prototype.toString.call(null);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>数组对象通过this绑定调用Array.prototype.toString()方法，返回数组值的字符串拼接<br>非数组对象通过this绑定调用Array.prototype.toString()方法，返回的是该对象的字符串表示<br>另外null和undefined不可以通过绑定调用Array.prototype.toString()方法。</p>\n</blockquote>\n<p>3 函数 function<br>toString()：返回函数的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    console.log(&apos;function&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.toString();</span><br><span class=\"line\">&lt;!--&quot;function foo()&#123;--&gt;</span><br><span class=\"line\">&lt;!--    console.log(&apos;function&apos;);--&gt;</span><br><span class=\"line\">&lt;!--&#125;&quot;--&gt;</span><br><span class=\"line\">Function.prototype.toString.call(foo);</span><br><span class=\"line\">&lt;!--&quot;function foo()&#123;--&gt;</span><br><span class=\"line\">&lt;!--    console.log(&apos;function&apos;);--&gt;</span><br><span class=\"line\">&lt;!--&#125;&quot;--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// Object Function Array本质都是构造函数</span><br><span class=\"line\">Object.toString();</span><br><span class=\"line\">// &quot;function Object() &#123; [native code] &#125;&quot;</span><br><span class=\"line\">Function.toString();</span><br><span class=\"line\">// &quot;function Function() &#123; [native code] &#125;&quot;</span><br><span class=\"line\">Array.toString();</span><br><span class=\"line\">// &quot;function Array() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>非函数对象是否可以使用函数的toString方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.toString.call(&#123;&#125;)</span><br><span class=\"line\">&lt;!--Function.prototype.toString requires that &apos;this&apos; be a Function--&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除了上述提到的Object和Array两种情况，其他类型都不支持非自身实例通过this绑定调用该Object子类原型对象上的toString()方法，这说明它们在重写toString()方法时，明确限定了调用该方法的对象类型，非自身对象实例不可调用。所以，<strong>一般我们只使用Object.prototype.toString.call/apply()方法。</strong></p>\n</blockquote>\n<p>4 日期 Date<br>toString()：返回带有时区信息的日期和时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var date = new Date();</span><br><span class=\"line\">date.toString();</span><br><span class=\"line\">//&quot;Fri May 11 2019 14:55:43 GMT+0800 (中国标准时间)&quot;</span><br><span class=\"line\">Date.prototype.toString.call(date);</span><br><span class=\"line\">//&quot;Fri May 11 2019 14:55:43 GMT+0800 (中国标准时间)&quot;</span><br></pre></td></tr></table></figure>\n\n<p>5 正则 RegExp<br>toString()：返回正则表达式的字面量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /cat/g;</span><br><span class=\"line\">re.toString();// &quot;/cat/g&quot;</span><br><span class=\"line\">RegExp.prototype.toString.call(re);// &quot;/cat/g&quot;</span><br></pre></td></tr></table></figure>\n\n<p>6 字符串 string<br>toString()：返回字符串的一个副本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;a&quot;;</span><br><span class=\"line\">str.toString(); //&quot;a&quot;</span><br><span class=\"line\">String.prototype.toString.call(str); //&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p>7 数字 number<br>toString()：返回字符串形式的数值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = 520;</span><br><span class=\"line\">num.toString(); //&quot;520&quot;</span><br><span class=\"line\">Number.prototype.toString.call(num); //&quot;520&quot;</span><br></pre></td></tr></table></figure>\n\n<p>8 布尔 boolean<br>toString()：返回字符串”true”或”false”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var boo = true;</span><br><span class=\"line\">boo.toString(); //&quot;true&quot;</span><br><span class=\"line\">Boolean.prototype.toString.call(boo); //&quot;true&quot;</span><br></pre></td></tr></table></figure>\n\n<p>9 null和undefined</p>\n<blockquote>\n<p>null和undefined没有相应的构造函数，所以它们没有也无法调用toString()方法，也就是说它们不能访问任何属性和方法，只是基本类型而已。</p>\n</blockquote>\n<p>10 全局对象window（Window类）<br>toString(): 返回对象的字符串表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.toString();</span><br><span class=\"line\">&lt;!--&quot;[object Window]&quot;--&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Winodw类并没有在Window.prototype原型对象上重写toString()方法，它会顺着原型链查找调用Object.prototype.toString()。<br>所以上述代码为：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(window);</span><br><span class=\"line\">&lt;!--&quot;[object Window]&quot;--&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>toString.call()</strong><br> toString.call()和toString()直接调用一样都返回[object Undefined],</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toString.call() // [object Undefined]</span><br><span class=\"line\">toString() // [object Undefined]</span><br><span class=\"line\">window.toString.call() // [object Undefined]</span><br><span class=\"line\">window.toString.call(undefined) // [object Undefined]</span><br><span class=\"line\">Object.prototype.toString.call() // [object Undefined]</span><br><span class=\"line\">Object.prototype.toString.call(undefined) // [object Undefined]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>所以toString.call()相当于<br>window.toString.call()  -&gt; window.toString.call(undefined) -&gt; Object.prototype.toString.call()  -&gt;Object.prototype.toString.call(undefined)</p>\n</blockquote>\n<p><strong>所以用Object.prototype.toString.call() 判断类型可以简写为toString.call()来判断</strong><br>  但是要注意如果已经有定义了toString函数就不可以使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toString()&#123;</span><br><span class=\"line\">    console.log(&quot;kimi&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">toString(); //&quot;kimi&quot;</span><br><span class=\"line\">toString.call(&#123;&#125;); //&quot;kimi&quot;</span><br><span class=\"line\">toString.call([]); //&quot;kimi&quot;</span><br></pre></td></tr></table></figure>\n\n","categories":["前端技术"],"tags":["javascript"]},{"title":"about","url":"/about/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"/link/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"/tag/index.html","content":"","categories":[],"tags":[]}]