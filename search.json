[{"title":"javascript基础-语句","url":"/2019/09/01/js_yufa/","content":"<h2 id=\"1-js语句\"><a href=\"#1-js语句\" class=\"headerlink\" title=\"1. js语句\"></a>1. js语句</h2><p>所有的js语句其实都会返回结果</p>\n<blockquote>\n<p>在调试工具中执行 var a = 12 会返回undefined ，表示声明变量会返回undefined</p>\n</blockquote>\n<h2 id=\"2-表达式的副作用\"><a href=\"#2-表达式的副作用\" class=\"headerlink\" title=\"2. 表达式的副作用\"></a>2. 表达式的副作用</h2><p>函数执行的时候，有可能会改变全局变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function boo() &#123;</span><br><span class=\"line\">\ta = a + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a =  1;</span><br><span class=\"line\">boo(); // a被改变</span><br></pre></td></tr></table></figure>\n\n<p>a++表示先赋值再++。 就是用括号扩起来也没有用。想让他++完之后再赋值。需要使用逗号表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 42;</span><br><span class=\"line\">a = a++; // 42</span><br><span class=\"line\">a = (a++) //42</span><br><span class=\"line\">a = (a++, a) // 43</span><br></pre></td></tr></table></figure>\n\n<p>在连续赋值时要注意，如果b没有声明则会创建一个全局变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = b =42 ; 会创建一个全局变量 严格模式报错</span><br></pre></td></tr></table></figure>\n\n<p>也可以利用赋值语句的副作用。先执行再赋值。接着判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以利用赋值语句</span><br><span class=\"line\">function vowels(str) &#123;</span><br><span class=\"line\">\tvar matches;\t</span><br><span class=\"line\">\tif(str &amp;&amp; (matches = str.match(/[aeiou]/g))) &#123;</span><br><span class=\"line\">\t\t// 先判断 如果成功将值赋值给matches 失败返回null不进判断</span><br><span class=\"line\">\t\treturn matches;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vowels(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-大括号\"><a href=\"#3-大括号\" class=\"headerlink\" title=\"3. 大括号\"></a>3. 大括号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">\tfoo: bar()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>去掉var a =不会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tfoo: bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 因为&#123;&#125;只是I个普通的代码块。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>而foo:bar()不会报错的原因是因为foo:被当成了标签, js的标签语法用来break和continue</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tbar: &#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;hello&apos;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbreak bar;</span><br><span class=\"line\">\tconsole.log(666)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() // hello</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-else-if\"><a href=\"#4-else-if\" class=\"headerlink\" title=\"4. else if\"></a>4. else if</h2><p>js中本身是没有else if的 是因为if else后面可以省略大括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if () &#123;</span><br><span class=\"line\">\t//</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\tif () &#123;</span><br><span class=\"line\">\t\t// </span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if () &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-switch\"><a href=\"#5-switch\" class=\"headerlink\" title=\"5. switch\"></a>5. switch</h2><p>switch中是===判断 如果想用==</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &apos;42&apos;;</span><br><span class=\"line\">switch(true) &#123;</span><br><span class=\"line\">\tcase a == 10;</span><br><span class=\"line\">\t\tconsole.log(1);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase a == 42;</span><br><span class=\"line\">\t\tconsole.log(2);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tdefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["前端技术"],"tags":["javascript基础"]},{"title":"promise下","url":"/2019/08/25/js_promise3/","content":"<h2 id=\"1-promise-catch\"><a href=\"#1-promise-catch\" class=\"headerlink\" title=\"1. promise catch\"></a>1. promise catch</h2><p>首先我们要明确其实catch就是<code>.then(null, rejection)</code>的语法糖。所以他仍然<code>返回一个promise</code>，可以继续.then执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class=\"line\">  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class=\"line\">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>\n\n<p>catch写法要比then中第二个参数要好。因为他捕获不到当前then第一个参数成功回调中的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(function(data) &#123;</span><br><span class=\"line\">    // success</span><br><span class=\"line\">  &#125;, function(err) &#123;</span><br><span class=\"line\">    // error</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(function(data) &#123; //cb</span><br><span class=\"line\">    // success</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function(err) &#123;</span><br><span class=\"line\">    // error</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-promise-all\"><a href=\"#2-promise-all\" class=\"headerlink\" title=\"2. promise all\"></a>2. promise all</h2><p>简单的promise源码实现如下：<br>内部会有计数器，等所有执行完毕后才会置换状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.all = function(promise) &#123;</span><br><span class=\"line\">  return new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">      let arr = [];</span><br><span class=\"line\">      let i = 0;</span><br><span class=\"line\">      let processData = (index, data) =&gt; &#123;</span><br><span class=\"line\">        arr[index] = data;</span><br><span class=\"line\">        if (++i === promises.length) &#123;</span><br><span class=\"line\">          resolve(arr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      for (let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class=\"line\">        let current = promises[i];</span><br><span class=\"line\">        if(isPromise(current)) &#123;</span><br><span class=\"line\">          current.then(data =&gt; &#123;</span><br><span class=\"line\">            processData(i, data);</span><br><span class=\"line\">          &#125;, reject)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          processData(i, current)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong>如果promise all中的promise有自己的catch方法。则不会走all的catch方法。会返回一个新的promise，并且resolve。所以会进入all的then中而不会走catch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;hello&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result)</span><br><span class=\"line\">.catch(e =&gt; e);</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  throw new Error(&apos;报错了&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result)</span><br><span class=\"line\">.catch(e =&gt; e);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2])</span><br><span class=\"line\">.then(result =&gt; console.log(result))</span><br><span class=\"line\">.catch(e =&gt; console.log(e));</span><br><span class=\"line\">// [&quot;hello&quot;, Error: 报错了]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-promise-race\"><a href=\"#3-promise-race\" class=\"headerlink\" title=\"3. promise race\"></a>3. promise race</h2><p>只要有一个状态改变，就马上返回。所以他的源码比all要简单。没有计数器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.all = function(promise) &#123;</span><br><span class=\"line\">  return new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">      for (let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class=\"line\">        let current = promises[i];</span><br><span class=\"line\">        if(isPromise(current)) &#123;</span><br><span class=\"line\">          current.then(data =&gt; &#123;</span><br><span class=\"line\">            resolve(i, data);</span><br><span class=\"line\">          &#125;, reject)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          resolve(i, current)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>promise.race可以很多改变状态的操作，比如取消promise。或者像如下 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([</span><br><span class=\"line\">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class=\"line\">  new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(console.log)</span><br><span class=\"line\">.catch(console.error);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-promise-finally\"><a href=\"#4-promise-finally\" class=\"headerlink\" title=\"4. promise.finally\"></a>4. promise.finally</h2><p>promise.finally 的源码也很简单。执行下回调并且<code>原值返回</code>之前的参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.prototype.finally = function (callback) &#123;</span><br><span class=\"line\">  let P = this.constructor;</span><br><span class=\"line\">  return this.then(</span><br><span class=\"line\">    value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class=\"line\">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-如何终止一个promise\"><a href=\"#5-如何终止一个promise\" class=\"headerlink\" title=\"5. 如何终止一个promise\"></a>5. 如何终止一个promise</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">  resolve(new Promise(resolve=&gt;&#123;&#125;));  // return一个pendding状态的promise即可</span><br><span class=\"line\">&#125;).then(res =&gt; &#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-如果取消一个promise\"><a href=\"#6-如果取消一个promise\" class=\"headerlink\" title=\"6. 如果取消一个promise\"></a>6. 如果取消一个promise</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function race(p)&#123;</span><br><span class=\"line\">    let obj = &#123;&#125;;</span><br><span class=\"line\">    // 定义一个空的promise。保存它的resolve 、reject 状态</span><br><span class=\"line\">    let p1 = new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        obj.resolve = resolve;</span><br><span class=\"line\">        obj.reject = reject;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    obj.promise = Promise.race([p, p1]);</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 需要取消时直接调用空promise的resolve即可。</span><br><span class=\"line\">// 这样race就会走成功，并且忽略掉传入的promise。达到取消的目的</span><br><span class=\"line\"> obj.resolve(cancelReason);</span><br></pre></td></tr></table></figure>","categories":["前端技术"],"tags":["js异步系列","es6"]},{"title":"promise中","url":"/2019/08/24/js_promise2/","content":"<h2 id=\"1-promise-then\"><a href=\"#1-promise-then\" class=\"headerlink\" title=\"1. promise then\"></a>1. promise then</h2><p>上一节<a href=\"https://www.jianshu.com/p/cdad8b501b63\" target=\"_blank\" rel=\"noopener\">promise上</a>已经根据promise/A+规范写出了基本的Promise类的基本框架。</p>\n<p>那么在promise/A+规范中还有几个关于then中的规范没有实现。</p>\n<ol>\n<li>如果返回一个普通值，会走下一个then的成功回调</li>\n<li>如果返回一个promise，会将他执行完的状态给下一个then</li>\n<li>如果抛出错误，会走下一个then的reject方法</li>\n<li>返回一个新的promise。实现链式调用</li>\n</ol>\n<h3 id=\"（1）-返回一个新的promise。实现链式调用\"><a href=\"#（1）-返回一个新的promise。实现链式调用\" class=\"headerlink\" title=\"（1） 返回一个新的promise。实现链式调用\"></a>（1） 返回一个新的promise。实现链式调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val;</span><br><span class=\"line\">    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err&#125;;</span><br><span class=\"line\">    // 因为then中的回调函数是异步执行的。为了确保newPromise存在，需要setTimeout</span><br><span class=\"line\">    let newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">                // 如果执行then中报错，需要直接reject</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                     // 执行下then中的方法的返回值当成下一个then的参数传递</span><br><span class=\"line\">                    let x = onFulfilled(this.value);</span><br><span class=\"line\">                    // 返回值有多种情况。普通值或者还是一个promise</span><br><span class=\"line\">                    resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">                &#125; catch(err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (this.status === REJECTED) &#123;</span><br><span class=\"line\">                // 如果失败的then中有报错或者还返回一个promise直接向后传递即可</span><br><span class=\"line\">                let x = onRejected(this.reason);</span><br><span class=\"line\">                reject(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (this.status === PENDING) &#123;</span><br><span class=\"line\">                this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        let x = onFulfilled(this.value);</span><br><span class=\"line\">                        resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">                    &#125; catch(err) &#123;</span><br><span class=\"line\">                        reject(err);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">                    let x = onRejected(this.reason);</span><br><span class=\"line\">                    reject(x);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return newPromise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）如果then中执行后返回的还是一个promise\"><a href=\"#（2）如果then中执行后返回的还是一个promise\" class=\"headerlink\" title=\"（2）如果then中执行后返回的还是一个promise\"></a>（2）如果then中执行后返回的还是一个promise</h3><p>定义resolvePromise 函数来分情况处理then中返回的结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  // 处理x的类型来决定下次then的状态是resolve还是reject</span><br><span class=\"line\">  // promise2 === x的情况就相当于</span><br><span class=\"line\">  // new Promise(resolve =&gt; resolve(1)).then(res =&gt; a1);</span><br><span class=\"line\">  if (promise2 === x) &#123;</span><br><span class=\"line\">    return reject(new TypeError(`Chaining cycle detected for promise #&lt;Promise&gt;`));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let called = false;</span><br><span class=\"line\">  // 判断x是不是一个普通函数 </span><br><span class=\"line\">  if (typeof x === &apos;object&apos; &amp;&amp; x !== null || typeof x === &apos;function&apos;) &#123;</span><br><span class=\"line\">    // 判断是否有then方法来判断是不是promise </span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      let then = x.then;</span><br><span class=\"line\">      if (typeof then === &apos;function&apos;) &#123;</span><br><span class=\"line\">        // 是promise情况 使用then.call来执行x.then方法是为了避免有的对象写的只能获取一次。</span><br><span class=\"line\">        // x.then需要再获取一次 而then.call是上次的缓存</span><br><span class=\"line\">        then.call(x, y =&gt; &#123;</span><br><span class=\"line\">          // 参数可能还是promise需要递归</span><br><span class=\"line\">          // .then(res =&gt; new Promise(resolve =&gt; resolve(new Promise..)))</span><br><span class=\"line\">          resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">        &#125;, r =&gt; &#123;</span><br><span class=\"line\">          if (called) return; // 防止多次调用</span><br><span class=\"line\">          called = true;</span><br><span class=\"line\">          reject(r)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123; // [1,2,3] &#123;a:1&#125;</span><br><span class=\"line\">        resolve(x);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; catch(err) &#123;</span><br><span class=\"line\">      if (called) return; // 防止多次调用</span><br><span class=\"line\">      called = true;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 不是对象或者函数 普通值</span><br><span class=\"line\">    resolve(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）返回值为promise\"><a href=\"#（3）返回值为promise\" class=\"headerlink\" title=\"（3）返回值为promise\"></a>（3）返回值为promise</h3><p>如果then中返回promise，也是需要等待这个新的promise执行完毕。直到返回一个resolve()为普通值的promise为止。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(resolve =&gt; resolve(1)).then(res =&gt; &#123;</span><br><span class=\"line\">  return new Promise(resolve =&gt; resolve(res))</span><br><span class=\"line\">&#125;).then(res =&gt; &#123;console.log(2)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 所以return 一个new promise，也是要先调用它的then方法返回一个新的promise</span><br><span class=\"line\">// 返回的新的promise继续then讲返回值向后抛</span><br><span class=\"line\">// 和resolve(Promise...) 一样 都是相当于加了2个then</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(1))</span><br><span class=\"line\">.then(res =&gt; res)</span><br><span class=\"line\">.then(res =&gt; res).then(res =&gt; res)  // 这两个就相当于新增的2个</span><br><span class=\"line\">.then(res =&gt; &#123;</span><br><span class=\"line\">  console.log(2)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果promise当作resolve()的参数或者在then中直接返回。则相当于多加了2次then</p>\n</blockquote>\n<h2 id=\"2-Promise-resolve-和-Promise-reject\"><a href=\"#2-Promise-resolve-和-Promise-reject\" class=\"headerlink\" title=\"2. Promise.resolve() 和 Promise.reject()\"></a>2. Promise.resolve() 和 Promise.reject()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(&apos;foo&apos;)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(&apos;foo&apos;));</span><br></pre></td></tr></table></figure>\n\n<p>但是参数是分4种情况的：</p>\n<h3 id=\"（1）参数是一个-Promise-实例\"><a href=\"#（1）参数是一个-Promise-实例\" class=\"headerlink\" title=\"（1）参数是一个 Promise 实例\"></a>（1）参数是一个 Promise 实例</h3><p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// resolve()参数还是promise则相当于多加两个then</span><br><span class=\"line\">const p = new Promise(resovle =&gt; setTimeout(resovle));</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(p)).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;3&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;1&quot;);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 1 2 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 而如果Promise.resolve() 参数中的Promise则是直接替换</span><br><span class=\"line\">const p = new Promise(resovle =&gt; setTimeout(resovle));</span><br><span class=\"line\">Promise.resolve(p).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;3&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;1&quot;);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 3 1 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）参数是一个thenable对象\"><a href=\"#（2）参数是一个thenable对象\" class=\"headerlink\" title=\"（2）参数是一个thenable对象\"></a>（2）参数是一个thenable对象</h3><p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable = &#123;</span><br><span class=\"line\">  then: function(resolve, reject) &#123;</span><br><span class=\"line\">    resolve(42);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable = &#123;</span><br><span class=\"line\">  then: function(resolve, reject) &#123;</span><br><span class=\"line\">    resolve(42);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let p1 = Promise.resolve(thenable);</span><br><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value);  // 42</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。</p>\n<h3 id=\"（3）参数不是具有then方法的对象，或根本就不是对象\"><a href=\"#（3）参数不是具有then方法的对象，或根本就不是对象\" class=\"headerlink\" title=\"（3）参数不是具有then方法的对象，或根本就不是对象\"></a>（3）参数不是具有then方法的对象，或根本就不是对象</h3><p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.resolve(&apos;Hello&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(function (s)&#123;</span><br><span class=\"line\">  console.log(s)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// Hello</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>等价于new Promise(resolve =&gt; resolve(‘Hello’));</p>\n</blockquote>\n<h3 id=\"（4）不带有任何参数\"><a href=\"#（4）不带有任何参数\" class=\"headerlink\" title=\"（4）不带有任何参数\"></a>（4）不带有任何参数</h3><p>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。<br>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(function (res) &#123;</span><br><span class=\"line\">  // res undefined</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的变量p就是一个 Promise 对象。</p>\n","categories":["前端技术"],"tags":["js异步系列","es6"]},{"title":"promise上","url":"/2019/08/22/js_promise1/","content":"<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>\n<p>promise用法可以参考：<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">promise用法</a><br>promise/A+ 规范: <a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">promise/A+</a><br>promise/A+中文翻译： <a href=\"https://juejin.im/post/5b6161e6f265da0f8145fb72\" target=\"_blank\" rel=\"noopener\">promise/A+中文</a></p>\n<p>简单的使用就不在探究了。可以自行查看文档。这里只把使用上表现结合起来探究其原理，并手写一个Promise</p>\n<h2 id=\"promise主体\"><a href=\"#promise主体\" class=\"headerlink\" title=\"promise主体\"></a>promise主体</h2><p>根据promise/A+规范</p>\n<ol>\n<li>promise是一个类。</li>\n<li>每次new一个Promise时都需要传递一个执行器。是立即执行的</li>\n<li>执行器中有两个参数resolve、reject</li>\n<li>默认promise中有是三个状态，pendding、fulfilled、rejected<br>pendding -&gt; resolve 就代表成功fulfilled<br>pendding -&gt; reject 就代表成功rejected</li>\n<li>如果一旦状态改变为成功或失败，就不能再变回失败或成功了</li>\n<li>每个promise都有一个then方法</li>\n</ol>\n<p>先根据如下规范可以写出promise的大体框架</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const PENDING = &apos;PENDING&apos;</span><br><span class=\"line\"> const FULFILLED = &apos;FULFILLED&apos;</span><br><span class=\"line\"> const REJECTED = &apos;REJECTED&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Promise &#123;</span><br><span class=\"line\">    constructor(executor) &#123;</span><br><span class=\"line\">        // 保存成功后的信息 resolve(222)  -&gt; 222</span><br><span class=\"line\">        this.value = undefined;</span><br><span class=\"line\">        // 保存失败后的错误 reject(333)  -&gt; 333</span><br><span class=\"line\">        this.reason = undefined;</span><br><span class=\"line\">        // 保存promise状态</span><br><span class=\"line\">        this.status = PENDING;</span><br><span class=\"line\">        // 调用resolve()时的回调</span><br><span class=\"line\">        let resolve = value =&gt; &#123;</span><br><span class=\"line\">              this.value = value;</span><br><span class=\"line\">              this.status = FULFILLED;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        // 调用reject()时的回调</span><br><span class=\"line\">        let resolve = reason =&gt; &#123;</span><br><span class=\"line\">              this.reason = reason;</span><br><span class=\"line\">              this.status = REJECTED;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        // new Promise(executor) 立即执行执行器，传入回调</span><br><span class=\"line\">        executor(resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 外界调用的then函数</span><br><span class=\"line\">    then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        // 当状态为成功时，调用p.then((res) =&gt; &#123;&#125;)传入的第一个回调</span><br><span class=\"line\">        if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">           onFulfilled(this.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 当状态为成功时，调用p.then(null, (res) =&gt; &#123;&#125;)传入的第二个回调</span><br><span class=\"line\">        if (this.status === REJECTED) &#123;</span><br><span class=\"line\">           onRejected(this.reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-执行器executor在new-Promise时是立即执行的。\"><a href=\"#1-执行器executor在new-Promise时是立即执行的。\" class=\"headerlink\" title=\"1.执行器executor在new Promise时是立即执行的。\"></a>1.执行器executor在new Promise时是立即执行的。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;console.log(1)&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-规范中规定-如果一旦状态改变为成功或失败，就不能再变回失败或成功了\"><a href=\"#2-规范中规定-如果一旦状态改变为成功或失败，就不能再变回失败或成功了\" class=\"headerlink\" title=\"2. 规范中规定: 如果一旦状态改变为成功或失败，就不能再变回失败或成功了\"></a>2. 规范中规定: 如果一旦状态改变为成功或失败，就不能再变回失败或成功了</h3><p>所以代码需要改写，增加判断当前状态是不是PENDDING，如果是才能修改状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用resolve()时的回调</span><br><span class=\"line\">let resolve = value =&gt; &#123;</span><br><span class=\"line\">  if(this.status === PENDDING) &#123;</span><br><span class=\"line\">      this.value = value;</span><br><span class=\"line\">      this.status = FULFILLED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// 调用reject()时的回调</span><br><span class=\"line\">let resolve = reason =&gt; &#123;</span><br><span class=\"line\">  if(this.status === PENDDING) &#123;</span><br><span class=\"line\">      this.reason= reason;</span><br><span class=\"line\">      this.status = REJECTED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-在使用中不关使用reject-可以抛出错误，直接使用throw-new-Error也可以进入rejected逻辑\"><a href=\"#3-在使用中不关使用reject-可以抛出错误，直接使用throw-new-Error也可以进入rejected逻辑\" class=\"headerlink\" title=\"3. 在使用中不关使用reject()可以抛出错误，直接使用throw new Error也可以进入rejected逻辑\"></a>3. 在使用中不关使用reject()可以抛出错误，直接使用throw new Error也可以进入rejected逻辑</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;throw new Error(666)&#125;)</span><br><span class=\"line\">p.then(null, err =&gt; &#123;console.log(err)&#125;)</span><br><span class=\"line\">// vendor.7ab21e702e7733b6b702.js:1 Error: 666</span><br></pre></td></tr></table></figure>\n\n<p>所以需要在调用执行器时加入try… catch</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// new Promise(executor) 立即执行执行器，传入回调</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">       executor(resolve, reject);</span><br><span class=\"line\">   &#125; catch(e) &#123;</span><br><span class=\"line\">       // 如果有throw的错误，直接执行reject回调</span><br><span class=\"line\">       reject(e);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-如果执行器中有异步操作。则调用then时有可能还是pendding状态。\"><a href=\"#4-如果执行器中有异步操作。则调用then时有可能还是pendding状态。\" class=\"headerlink\" title=\"4. 如果执行器中有异步操作。则调用then时有可能还是pendding状态。\"></a>4. 如果执行器中有异步操作。则调用then时有可能还是pendding状态。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        resolve(666)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 或者ajax请求等异步操作</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>所以需要增加逻辑判断。并利用发布订阅。在构造函数中定义onResolvedCallbacks和onRejectedCallbacks队列，如果是pendding状态则将回调push入队列中。在异步执行完毕调用resolve()或者reject()时。去回调中执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor &#123;</span><br><span class=\"line\">    // 再定义两个队列</span><br><span class=\"line\">    this.onResolvedCallbacks = [];</span><br><span class=\"line\">    this.onRejectedCallbacks = [];</span><br><span class=\"line\">    </span><br><span class=\"line\">// 调用resolve()时的回调</span><br><span class=\"line\"></span><br><span class=\"line\">    let resolve = value =&gt; &#123;</span><br><span class=\"line\">        if(this.status === PENDDING) &#123;</span><br><span class=\"line\">            this.value = value;</span><br><span class=\"line\">            this.status = FULFILLED;</span><br><span class=\"line\">            // 一旦调用resolve() 就把之前保存的异步回调都执行一遍</span><br><span class=\"line\">            this.onResolvedCallbacks.forEach(fn =&gt; fn());</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    // 调用reject()时的回调</span><br><span class=\"line\">    let resolve = reason =&gt; &#123;</span><br><span class=\"line\">        if(this.status === PENDDING) &#123;</span><br><span class=\"line\">            this.reason= reason;</span><br><span class=\"line\">            this.status = REJECTED;</span><br><span class=\"line\">            // 一旦调用reject() 就把之前保存的异步回调都执行一遍</span><br><span class=\"line\">            this.onRejectedCallbacks.forEach(fn =&gt; fn());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    if (this.status === PENDDING) &#123;</span><br><span class=\"line\">        this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">            // todo</span><br><span class=\"line\">            onFulfilled(this.value);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">            // todo</span><br><span class=\"line\">            onRejected(this.reason);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>回调为什么要定义成队列数组呢？</strong><br>因为一个promise实例有可能有多个then调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise(resolve =&gt; &#123;resolve(43)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(res =&gt; &#123;console.log(1)&#125;);</span><br><span class=\"line\">p.then(res =&gt; &#123;console.log(2)&#125;);</span><br><span class=\"line\">p.then(res =&gt; &#123;console.log(3)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 上面一个实例p，有三个then函数调用。所以会把他的onFulfilled回调都放入数组中</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-如果then中传入的不是函数\"><a href=\"#5-如果then中传入的不是函数\" class=\"headerlink\" title=\"5. 如果then中传入的不是函数\"></a>5. 如果then中传入的不是函数</h3><p>如果then中传入的不是函数，不会抛出错误，而会继续略过他继续向下传递</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise(resolve =&gt; resolve(43));</span><br><span class=\"line\">p.then(undefined, 443).then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class=\"line\">// 43</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以在then方法中需要添加容错处理。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    // 如果成功回调不是函数则将value继续向下传递，失败则将reason继续向后抛</span><br><span class=\"line\">    onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val;</span><br><span class=\"line\">    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123;throw err&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>then函数中的回调会放入微任务中。在下次eventLoop中执行。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise(resolve =&gt; resolve());</span><br><span class=\"line\">// 如果传入不是函数继续向下抛。则会再多执行一次then。需要2次eventLoop</span><br><span class=\"line\">p.then(2323, false).then(res =&gt; &#123;console.log(1)&#125;);</span><br><span class=\"line\">// 放入微任务 需要1次eventLoop</span><br><span class=\"line\">p.then(res =&gt; &#123;console.log(2)&#125;);</span><br><span class=\"line\">// 直接执行</span><br><span class=\"line\">console.log(3)</span><br><span class=\"line\"></span><br><span class=\"line\">// 3</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-如果resolve或者reject一个promise\"><a href=\"#6-如果resolve或者reject一个promise\" class=\"headerlink\" title=\"6. 如果resolve或者reject一个promise\"></a>6. 如果resolve或者reject一个promise</h3><p>如果是resolve(new Promise())的话，就用这个promise的状态作为下个then的状态。<br>如果是reject(new Promise())的话，不需要执行直接返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">  resolve(new Promise(resovle =&gt; resovle(1))) </span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);  // 1</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  reject(new Promise(resovle =&gt; resovle(1))) </span><br><span class=\"line\">&#125;).then(null, (res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);  // Promise &#123;&lt;resolved&gt;: 1&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>需要在成功的resolve()回调中增加判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const resolve = value =&gt; &#123;</span><br><span class=\"line\">    // 如果resolve()参数传入的是个promise，直接执行它的then方法。</span><br><span class=\"line\">    // 需要等待他执行完毕，拿到他的状态并且返回一个新的promise</span><br><span class=\"line\">    if (value instanceOf Promise) &#123;</span><br><span class=\"line\">        return value.then(resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">        this.status = FULFILLED;</span><br><span class=\"line\">        this.onResolvedCallbacks.forEach(fn =&gt; fn());</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">  resolve(new Promise(resovle =&gt; resovle(1))) </span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;tick 3&quot;);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;tick 4&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(resovle =&gt; resovle(1)).then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;tick 1&quot;);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;tick 2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 1 2 3 4</span><br><span class=\"line\"></span><br><span class=\"line\">// 因为resolve()一个promise需要等待他执行完毕，并且then方法返回一个新的promise。</span><br><span class=\"line\">// 相当于如下操作:</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(1)).then(res =&gt; &#123;</span><br><span class=\"line\">  // 调用resolve中promise的then，返回一个新的promise。</span><br><span class=\"line\">  // 这个promise的resolve值已经是普通值了。如果继续嵌套那就继续递归。</span><br><span class=\"line\">  // 如果then中return promise 还是会等待他执行完then方法的。</span><br><span class=\"line\">  return new Promise(resolve =&gt; resolve(res));</span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;tick 3&quot;,res);</span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;console.log(&apos;tick 4&apos;, 1)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 也就相当于多了两次then。</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(1)).then(res =&gt; res).then(res =&gt; res).then(res =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;tick 3&apos;)</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;tick 4&apos;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h3><p>所以根据上述promise/A+规范。写出最基本的Promise源码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PENDING = &apos;PENDING&apos;;</span><br><span class=\"line\">const FULFILLED = &apos;FULFILLED&apos;;</span><br><span class=\"line\">const REJECTED = &apos;REJECTED&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Promise &#123;</span><br><span class=\"line\">    constructor (executor) &#123;</span><br><span class=\"line\">        this.value = undefined;</span><br><span class=\"line\">        this.reason = undefined;</span><br><span class=\"line\">        this.status = PENDING;</span><br><span class=\"line\">        this.onResolvedCallbacks = [];</span><br><span class=\"line\">        this.onRejectedCallbacks = [];</span><br><span class=\"line\"></span><br><span class=\"line\">        const resolve = value =&gt; &#123;</span><br><span class=\"line\">            if (value instanceOf Promise) &#123;</span><br><span class=\"line\">                return value.then(resolve, reject);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (this.status === PENDING) &#123;</span><br><span class=\"line\">                this.value = value;</span><br><span class=\"line\">                this.status = FULFILLED;</span><br><span class=\"line\">                this.onResolvedCallbacks.forEach(fn =&gt; fn());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reject = reason =&gt; &#123;</span><br><span class=\"line\">            if (this.status === PENDING) &#123;</span><br><span class=\"line\">                this.reason = reason;</span><br><span class=\"line\">                this.status = REJECTED;</span><br><span class=\"line\">                this.onRejectedCallbacks.forEach(fn =&gt; fn());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            executor(resolve, reject);</span><br><span class=\"line\">        &#125; catch (error) &#123;</span><br><span class=\"line\">            reject(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val;</span><br><span class=\"line\">        onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">            onFulfilled(this.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (this.status === REJECTED) &#123;</span><br><span class=\"line\">            onRejected(this.reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (this.status === PENDING) &#123;</span><br><span class=\"line\">            this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">                onFulfilled(this.value);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">                onRejected(this.reason);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["前端技术"],"tags":["js异步系列","es6"]},{"title":"js异步发展史","url":"/2019/08/19/js_async/","content":"<h2 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h2><p>最早为了实现局部请求无刷新，有了ajax的概念。在原生js是时代，请求数据都需要自己手写一个ajax。现在还有很多面试题会让手写一个ajax</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先实例化一个XMLHttpRequest对象</span><br><span class=\"line\">const xhr = new XMLHttpRequest()</span><br><span class=\"line\"></span><br><span class=\"line\">// xhr 具有一个 open 方法，相当于填写配置先初始化。这时候没有发出请求</span><br><span class=\"line\">// method： 请求方式 —— get / post</span><br><span class=\"line\">// url：请求的地址</span><br><span class=\"line\">// async：是否异步请求，默认为 true（异步）</span><br><span class=\"line\">xhr.open(method, url, async)</span><br><span class=\"line\"></span><br><span class=\"line\">// send 方法发送请求，并接受一个可选参数</span><br><span class=\"line\">// 当请求方式为 post 时，可以将请求体的参数传入</span><br><span class=\"line\">// 当请求方式为 get 时，可以不传或传入 null</span><br><span class=\"line\">xhr.send(data)</span><br><span class=\"line\"></span><br><span class=\"line\">// xhr上有一个readyStatus值。他会随着请求的阶段不同而变化：</span><br><span class=\"line\">// xhr.readyStatus==0 尚未调用 open 方法</span><br><span class=\"line\">// xhr.readyStatus==1 已调用 open 但还未发送请求（未调用 send）</span><br><span class=\"line\">// xhr.readyStatus==2 已发送请求（已调用 send）</span><br><span class=\"line\">// xhr.readyStatus==3 已接收到请求返回的数据</span><br><span class=\"line\">// xhr.readyStatus==4 请求已完成</span><br><span class=\"line\"></span><br><span class=\"line\">// 当readyStatus变化时都会执行onreadystatechange 回调。</span><br><span class=\"line\">// responseText： 请求返回的数据内容</span><br><span class=\"line\">// status： 响应的HTTP状态，如 200 304 404 等</span><br><span class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">    if (xhr.readyStatus === 4) &#123;</span><br><span class=\"line\">        if (xhr.status &gt;= 200 &amp;&amp; </span><br><span class=\"line\">            xhr.status &lt; 300 || </span><br><span class=\"line\">            xhr.status == 304) &#123;</span><br><span class=\"line\">            console.log(&apos;请求成功&apos;, xhr.responseText)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置超时时间为1000毫秒</span><br><span class=\"line\">xhr.timeout = 1000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h2><p>后来在jquery盛行的时代。将ajax封装成了一个函数。可以直接调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;  </span><br><span class=\"line\">  type : &quot;POST&quot;,</span><br><span class=\"line\">  url:&apos;http://aaaa.com&apos;,</span><br><span class=\"line\">  async：true，</span><br><span class=\"line\">  dataType：&apos;json&apos;,</span><br><span class=\"line\">  data:&#123;a:&apos;aa&apos;&#125;,</span><br><span class=\"line\">  success :function(msg)&#123;</span><br><span class=\"line\">      //请求成功函数</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error:function(err)&#123;</span><br><span class=\"line\">      //请求失败函数</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"jquery1-5之后\"><a href=\"#jquery1-5之后\" class=\"headerlink\" title=\"jquery1.5之后\"></a>jquery1.5之后</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ajax = $.ajax(&apos;data.json&apos;)</span><br><span class=\"line\">ajax.done(function () &#123;</span><br><span class=\"line\">        console.log(&apos;success 1&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .fail(function () &#123;</span><br><span class=\"line\">        console.log(&apos;error&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .done(function () &#123;</span><br><span class=\"line\">         console.log(&apos;success 2&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(ajax) // 返回一个 deferred 对象</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>区别:<br>之前返回的是一个XHR对象，这个对象不可能有done或者fail的方法的<br>1.5开始返回一个deferred对象，这个对象就带有done和fail的方法，并且是等着请求返回之后再去调用</p>\n</blockquote>\n<h2 id=\"promise前身\"><a href=\"#promise前身\" class=\"headerlink\" title=\"promise前身\"></a>promise前身</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 改造前</span><br><span class=\"line\">var wait = function() &#123;</span><br><span class=\"line\">\tvar task = function () &#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;ok&apos;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsetTimeout(task, 2000)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait()</span><br><span class=\"line\">// 改造后\t</span><br><span class=\"line\">function waitHandle() &#123;</span><br><span class=\"line\">\tvar dtd = $.Deferred()\t</span><br><span class=\"line\">\tvar wait = function(dtd) &#123;</span><br><span class=\"line\">        var task = function() &#123;</span><br><span class=\"line\">\t\t    console.log(&apos;ok&apos;);</span><br><span class=\"line\">\t\t    dtd.resolve()</span><br><span class=\"line\">\t\t    // dtd.reject() </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    setTimeout(task, 2000)</span><br><span class=\"line\">\t\treturn dtd.promise() // 返回promise对象，使用时不可以修改状态。promise的前身</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn wait(dtd);</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">waitHandle().then();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>1.5改造之后最大的好处就是可以通过then的方法来链式调用。不再会有回调地狱。而且状态一旦改变，也不能再变成其他状态了。和之后的promise一样。</p>\n</blockquote>\n<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h2><p>es6中将之前社区中的方案正式纳入标准，制定了promise/A+规范。也就可以直接的使用promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const getJSON = function(url) &#123;</span><br><span class=\"line\">  const promise = new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">    const handler = function() &#123;</span><br><span class=\"line\">      if (this.readyState !== 4) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (this.status === 200) &#123;</span><br><span class=\"line\">        resolve(this.response);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        reject(new Error(this.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const client = new XMLHttpRequest();</span><br><span class=\"line\">    client.open(&quot;GET&quot;, url);</span><br><span class=\"line\">    client.onreadystatechange = handler;</span><br><span class=\"line\">    client.responseType = &quot;json&quot;;</span><br><span class=\"line\">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class=\"line\">    client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return promise;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class=\"line\">  console.log(&apos;Contents: &apos; + json);</span><br><span class=\"line\">&#125;, function(error) &#123;</span><br><span class=\"line\">  console.error(&apos;出错了&apos;, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h2><blockquote>\n<p>promise的出现只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，会造成代码冗余。一堆的then。如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var readFile = require(&apos;fs-readfile-promise&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">readFile(fileA)</span><br><span class=\"line\">.then(function (data) &#123;</span><br><span class=\"line\">  console.log(data.toString());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(function () &#123;</span><br><span class=\"line\">  return readFile(fileB);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(function (data) &#123;</span><br><span class=\"line\">  console.log(data.toString());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(function (err) &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>于是有了更好的解决方案—<code>generator</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetch = require(&apos;node-fetch&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function* gen()&#123;</span><br><span class=\"line\">  var url = &apos;https://api.github.com/users/github&apos;;</span><br><span class=\"line\">  var result = yield fetch(url);</span><br><span class=\"line\">  console.log(result.bio);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var g = gen();</span><br><span class=\"line\">var result = g.next();</span><br><span class=\"line\"></span><br><span class=\"line\">result.value.then(function(data)&#123;</span><br><span class=\"line\">  return data.json();</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">  g.next(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便，需要执行器`控制他什么时候执行第一步，什么时候执行第二步。并且传递参数。</p>\n</blockquote>\n<p>于是有了<code>co</code>这种流程管理库。</p>\n<p>简单的流程管理如下。会一直执行下去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* gen() &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var g = gen();</span><br><span class=\"line\">var res = g.next();</span><br><span class=\"line\"></span><br><span class=\"line\">while(!res.done)&#123;</span><br><span class=\"line\">  console.log(res.value);</span><br><span class=\"line\">  res = g.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"async-await-–终极方案\"><a href=\"#async-await-–终极方案\" class=\"headerlink\" title=\"async await –终极方案\"></a>async await –终极方案</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function getStockPriceByName(name) &#123;</span><br><span class=\"line\">  const symbol = await getStockSymbol(name);</span><br><span class=\"line\">  const stockPrice = await getStockPrice(symbol);</span><br><span class=\"line\">  return stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getStockPriceByName(&apos;goog&apos;).then(function (result) &#123;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>好处</strong><br>（1）内置执行器。<br>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getStockPriceByName();</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码调用了getStockPriceByName函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。</p>\n<p>（2）更好的语义。<br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>\n<p>（3）更广的适用性。<br>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>\n<p>（4）返回值是 Promise。<br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>\n<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n<blockquote>\n<p>在nodejs中已经使用async 、 await做为异步操作的解决方案</p>\n</blockquote>\n","categories":["前端技术"],"tags":["js异步系列"]},{"title":"观察者模式和发布订阅","url":"/2019/08/17/js_observer/","content":"<h2 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h2><p>js中的事件模型就是基于发布订阅设计的。相当于订报的人和送报人的关系。js中很多都有发布订阅的思想。具体上代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let e = &#123;</span><br><span class=\"line\">    arr: [],</span><br><span class=\"line\">    on(fn) &#123;</span><br><span class=\"line\">        this.arr.push(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    emit() &#123;</span><br><span class=\"line\">        this.arr.forEach(fn =&gt; fn());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">e.on(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;订阅者1&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">e.on(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;订阅者2&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">fs.readFile(&apos;name.txt&apos;, &apos;utf8&apos;, (err) =&gt; &#123;</span><br><span class=\"line\">    e.emit();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 只要文件读取成功后就会发布一个通知。然后执行所有订阅者的回调方法</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>从图中可以看出。发布者和订阅者是没有关系的。通过事件中心来做中介。订阅者可以通过on方法将自己的回调添加进订阅者队列。而发布者可以通过调用emit方法来通知订阅者执行回调。</p>\n</blockquote>\n<p><img src=\"/images/fabu.png\" alt=\"fabu.png\"></p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Sub &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.arr = [];</span><br><span class=\"line\">    this.name = &apos;kimi&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addWatcher(o) &#123;</span><br><span class=\"line\">    this.arr.push(o)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  rename(newName) &#123;</span><br><span class=\"line\">    this.name = newName;</span><br><span class=\"line\">    this.arr.forEach(o =&gt; o.update(newName));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Observer &#123;</span><br><span class=\"line\">    update(newName) &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let sub = new Sub();  </span><br><span class=\"line\">let o1 = new Observer();  </span><br><span class=\"line\">let o2 = new Observer();  </span><br><span class=\"line\">sub.addWatcher(o1);  // 添加第一位观察者</span><br><span class=\"line\">sub.addWatcher(o2);  // 添加第二位观察者</span><br><span class=\"line\">sub.rename(&apos;bob&apos;);  // 被观察者变化后通知观察者，调用观察者身上的update方法</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>观察者模式在前端中应用非常广泛。比如vue源码中。一个data可能有很多watcher观察者。render-watcher、computed-watcher、data-watcher。一旦数据发生变化就会通知观察者，调用他们自己的update方法。</p>\n</blockquote>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li>观察者模式中 观察者和被观察者一般是有关系的。而发布者和订阅者是没有关系的</li>\n<li>观察者模式中一般都会包含发布订阅。</li>\n<li>js中的事件，就是最好的发布订阅模型。</li>\n<li>数据视图双向绑定的框架都离不开观察者模式。</li>\n</ol>\n","categories":["前端技术"],"tags":["设计模式","js异步系列"]},{"title":"js eventLoop","url":"/2019/08/17/js_eventLoop/","content":"<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>  js是单线程是众所周知的事情，那么为什么js会被设计成单线程呢。因为如果js为多线程的话。如果一个线程在读取一个dom的信息。另一个线程是要把这个dom删除。这样就会造成混乱。所以js被设计成单线程的。</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>  那么由于js是单线程的。如果遇到ajax请求或者io操作的话。这个线程如果一直在等着请求返回。有可能这个返回时间也特别长。那么这个资源就一直消耗在这等待。所以js有了异步的的概念。任务也分为同步任务和异步任务两种</p>\n<h2 id=\"event-loop\"><a href=\"#event-loop\" class=\"headerlink\" title=\"event-loop\"></a>event-loop</h2><blockquote>\n<p>（1）所有同步任务都在主线程上执行，形成一个执行栈<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。<br><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</strong></p>\n</blockquote>\n<p><code>注意：</code>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。而异步任务一般都有回调函数。当主线程开始执行异步任务，就是执行对应的回调函数。如果遇到定时器会检查他的时间后执行。</p>\n<p><img src=\"/images/eventLoop.png\" alt=\"eventLoop.png\"></p>\n<h2 id=\"微任务和宏任务-（microtask和macrotask）\"><a href=\"#微任务和宏任务-（microtask和macrotask）\" class=\"headerlink\" title=\"微任务和宏任务 （microtask和macrotask）\"></a>微任务和宏任务 （microtask和macrotask）</h2><p>当执行以下方法函数，将把其<code>callback</code>推到宏任务队列中</p>\n<ol>\n<li><code>setTimeout</code>、<code>setInterval</code>和<code>setImmediate</code></li>\n<li><code>I/O操作</code>、<code>UI渲染</code>、<code>script脚本执行</code></li>\n<li><code>MessageChannel</code>(Vue的nexttick有使用)</li>\n</ol>\n<p>同理，不过是推到微任务队列</p>\n<ol>\n<li><code>Promise</code></li>\n<li><code>MutationObserver</code></li>\n<li><code>process.nextTick</code> (Node)</li>\n</ol>\n<p>在每次eventloop的时候会先执行微任务再执行宏任务。</p>\n<h2 id=\"process-nextTick和setImmediate\"><a href=\"#process-nextTick和setImmediate\" class=\"headerlink\" title=\"process.nextTick和setImmediate\"></a>process.nextTick和setImmediate</h2><p><code>process.nextTick</code>方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前。也就是说，它指定的任务总是发生在所有异步任务之前</p>\n<p><img src=\"/images/process.nextTick.jpg\" alt=\"process.nextTick.jpg\"></p>\n<p><code>setImmediate</code>方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像<br><img src=\"/images/setImmediate.jpg\" alt=\"setImmediate.jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(3);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 3</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>不论nextTick嵌套了多深。都会在下次EventLoop之前执行。所以如果递归调用nextTick时，node会报错。因为会卡死。而setImmediate嵌套多层也会在多个eventloop中执行。每写一个嵌套就多一次eventloop</p>\n</blockquote>\n<h2 id=\"setImmediate和setTimeout\"><a href=\"#setImmediate和setTimeout\" class=\"headerlink\" title=\"setImmediate和setTimeout\"></a>setImmediate和setTimeout</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setImmediate(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  setImmediate(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(3);</span><br><span class=\"line\">&#125;, 0);</span><br></pre></td></tr></table></figure>\n\n<p>如果只有setTimeout、setImmediate在主函数中时。<strong>执行顺序是随机的。</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setImmediate(function ()&#123;</span><br><span class=\"line\">  setImmediate(function A() &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    setImmediate(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(function timeout() &#123;</span><br><span class=\"line\">    console.log(3);</span><br><span class=\"line\">  &#125;, 0);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 3</span><br><span class=\"line\">// 2</span><br></pre></td></tr></table></figure>\n\n<p>如果在setImmediate的递归中同时存在setTimeout和setImmediate。<strong>这时的setImmediate总是在setTimeout之前执行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setImmediate(function A() &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    setImmediate(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">    console.log(3);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\">process.nextTick(()=&gt;&#123;console.log(4)&#125;)</span><br><span class=\"line\">// 4 3 1 2</span><br></pre></td></tr></table></figure>\n\n<p>还有种情况 如果主函数中写了其他的微任务（promise或者process.nextTick）。则总是setTimeout优先于setImmediate执行的。具体原因参考<a href=\"https://www.zhihu.com/question/23028843\" target=\"_blank\" rel=\"noopener\">setTimeout和setImmediate区别</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>process.nextTick()，效率最高，消费资源小，但会阻塞CPU的后续调用；<br>setTimeout()，精确度不高，可能有延迟执行的情况发生，且因为动用了红黑树，所以消耗资源大；<br>setImmediate()，消耗的资源小，也不会造成阻塞，但效率也是最低的。</p>\n<h2 id=\"实际举例\"><a href=\"#实际举例\" class=\"headerlink\" title=\"实际举例\"></a>实际举例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">    process.nextTick(() =&gt; &#123;</span><br><span class=\"line\">        console.log(3);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">        console.log(4);</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;).then(() =&gt; &#123;</span><br><span class=\"line\">        console.log(5)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    console.log(6);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(7);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">process.nextTick(() =&gt; &#123;</span><br><span class=\"line\">    console.log(8);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setImmediate(() =&gt; &#123;</span><br><span class=\"line\">    console.log(9);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    console.log(10);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(11);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(12);</span><br><span class=\"line\">    setImmediate(() =&gt; &#123;</span><br><span class=\"line\">        console.log(13);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    process.nextTick(() =&gt; &#123;</span><br><span class=\"line\">        console.log(14);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">        console.log(15);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(() =&gt; &#123;</span><br><span class=\"line\">        console.log(16);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">process.nextTick(() =&gt; &#123;</span><br><span class=\"line\">    console.log(17)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 1 6 10 8 17 7 11 2 4 12 15 3 14 5 16 9 13</span><br></pre></td></tr></table></figure>\n\n<p>执行栈执行：</p>\n<ol>\n<li>执行同步任务 <code>打印1</code></li>\n<li>遇到setTimeout放入宏任务队列中。</li>\n<li>遇到new promise时，new promise参数中的函数会立即执行。<code>打印6</code>，并且将状态置为resolve成功。这时候将then中的回调函数放入微任务队列中。</li>\n<li>遇到process.nextTick会放入下次eventloop之前。所有的异步任务之前</li>\n<li>遇到setImmediate会放入异步任务最后</li>\n<li>再遇到new promise同理，<code>打印10</code>，并且将then中回调放入微任务队列中</li>\n<li>遇到setTimeout放入宏任务队列中</li>\n<li>最后遇到process.nextTick会放入下次eventloop之前<br>执行栈结束</li>\n</ol>\n<p>第一次eventLoop</p>\n<ol start=\"9\">\n<li><p>找到process.nextTick放入的任务执行。<code>执行8 17</code></p>\n</li>\n<li><p>取出微任务队列中的任务执行。<code>执行7 11</code></p>\n</li>\n<li><p>取出宏任务队列中的任务执行。先执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">    process.nextTick(() =&gt; &#123;</span><br><span class=\"line\">        console.log(3);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">        console.log(4);</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;).then(() =&gt; &#123;</span><br><span class=\"line\">        console.log(5)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>打印2</code> </p>\n</li>\n<li><p>将process.nextTick放入下次eventloop之前</p>\n</li>\n<li><p>new promise参数中的函数立即执行，<code>打印4</code>。将then中的回调放入微任务队列</p>\n</li>\n<li><p>再执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(12);</span><br><span class=\"line\">    setImmediate(() =&gt; &#123;</span><br><span class=\"line\">        console.log(13);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    process.nextTick(() =&gt; &#123;</span><br><span class=\"line\">        console.log(14);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">        console.log(15);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(() =&gt; &#123;</span><br><span class=\"line\">        console.log(16);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>打印12</code></p>\n</li>\n<li><p>将setImmediate放入所有异步任务最后等待</p>\n</li>\n<li><p>将process.nextTick放入下次eventloop之前</p>\n</li>\n<li><p>new promise参数的函数立即执行，<code>打印15</code>。将then中的回调放入微任务队列<br>第一次eventLoop结束</p>\n</li>\n</ol>\n<p>第二次eventLoop</p>\n<ol start=\"20\">\n<li>先执行process.nextTick的任务 。<code>打印3 14</code></li>\n<li>发现微任务队列中还有上一轮加入的任务。<code>打印5 16</code></li>\n<li>所以异步任务队列中没有任务了。最后执行setImmediate任务 <code>打印 9 13</code></li>\n</ol>\n","categories":["前端技术"],"tags":["javascript基础","js异步系列"]},{"title":"javascript基础-js原型","url":"/2019/08/14/js_prototype/","content":"<h2 id=\"1-对象\"><a href=\"#1-对象\" class=\"headerlink\" title=\"1 对象\"></a>1 对象</h2><p>首先明确一点，对象都是通过函数创建的。let obj = {a:1} 只是一种快捷方式</p>\n<h2 id=\"2-原型-prototype\"><a href=\"#2-原型-prototype\" class=\"headerlink\" title=\"2 原型 prototype\"></a>2 原型 prototype</h2><p><img src=\"/images/constructor.png\" alt=\"constructor.png\"></p>\n<p><strong>每个函数都有一个prototype属性指向他的原型</strong>，这个prototype的属性值是一个对象，默认的只有一个叫做<code>constructor</code>的属性，指向这个函数本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo () &#123;&#125;</span><br><span class=\"line\">let a = new Foo();</span><br><span class=\"line\">a.constructor // 指向Foo，但是constructor属性是从prototype上继承来的。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo () &#123;&#125;</span><br><span class=\"line\">Foo.prototype = &#123;&#125; // 创建一个新原型对象</span><br><span class=\"line\">let a = new Foo();</span><br><span class=\"line\">a.constructor === Foo // false</span><br><span class=\"line\">a.constructor === Object // true  本身原型上没有了constructor 属性，则会沿着原型链查找到Object</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为每个对象都有一个隐藏的属性“<code>__proto__</code>”</strong>，这个属性引用了创建这个对象的函数的prototype。即：fn.<code>__proto__</code> === Fn.prototype。所以可以使用原型的方法</p>\n<p><img src=\"/images/prototype.png\" alt=\"prototype.png\"></p>\n<p><strong>总结: 每个函数function都有一个prototype原型。每个对象都有一个<code>__proto__</code>隐式原型。</strong></p>\n<h2 id=\"3-对象和函数关系\"><a href=\"#3-对象和函数关系\" class=\"headerlink\" title=\"3 对象和函数关系\"></a>3 对象和函数关系</h2><p>对象都是函数创建出来的，那么函数是谁创建的呢。—<strong>Function</strong><br><img src=\"/images/prototypePart.png\" alt=\"prototypePart.png\"></p>\n<p>再回顾下之前的总结</p>\n<blockquote>\n<p><strong>每个函数function都有一个prototype原型。每个对象都有一个<code>__proto__</code>隐式原型。</strong></p>\n</blockquote>\n<blockquote>\n<p>对于function Foo来说。他是函数。所以他就有一个prototype指向Foo.prototype，他也可以是对象（函数也是一种对象）。那么他也有一个<strong>proto</strong>指向创建他的函数的原型 Function.prototype</p>\n</blockquote>\n<p>所以我们来看Object和Function的关系，就有种鸡生蛋、蛋生鸡的感觉<br><img src=\"/images/prototypeAll.png\" alt=\"prototypeAll.png\"></p>\n<p>function Function当做函数时有prototype指向Function.prototype。当对象时有一个<code>__proto__</code>指向创建他的函数的原型 ，那么谁创建的函数呢 答案肯定还是Function自己。<strong>感觉是自己创建了自己</strong>。而Function.prototype是一个对象。所以他有<code>__proto__</code>指向创建他的函数的原型。对象是function Object创建的<br>所以Function.prototype.<code>__proto__</code> === Object.prototype</p>\n<p>function Object当做函数时有prototype指向Object.prototype。当对象时有一个<code>__proto__</code>指向创建他的函数的原型，函数肯定是Function创建的。那么就有Object.<code>__proto__</code> === Function.prototype。而Object.prototype对象的<code>__proto__</code>指向null。让原型链形成结束。</p>\n<p>正是因为这样，Object、Function之间形成了一个闭环.</p>\n<h2 id=\"4-Instanceof\"><a href=\"#4-Instanceof\" class=\"headerlink\" title=\"4 Instanceof\"></a>4 Instanceof</h2><p><strong>Instanceof的判断是：沿着A的<code>__proto__</code>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</strong><br>所以以下判断都成立</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object instanceof Function // true</span><br><span class=\"line\">Function instanceof Object // true</span><br><span class=\"line\">// Function 当作对象__proto__指向创建它的Function的原型Function.prototype。</span><br><span class=\"line\">// 而Function.prototype是个对象，他的__proto__指向Object.prototype。判断为true</span><br><span class=\"line\">Function instanceof Function // true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>instanceof表示的就是一种继承关系，或者原型链的结构<br><strong>javascript中的继承是通过原型链来体现的。原型继承</strong><br><strong>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是原型链。</strong></p>\n</blockquote>\n","categories":["前端技术"],"tags":["javascript基础"]},{"title":"javascript基础-js对象","url":"/2019/08/12/js_object/","content":"<h1 id=\"对象和原型\"><a href=\"#对象和原型\" class=\"headerlink\" title=\"对象和原型\"></a>对象和原型</h1><h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><blockquote>\n<p><strong>若干属性的集合就是对象，一切引用类型都是对象，都是属性的集合</strong></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2]</span><br><span class=\"line\">arr.name = &apos;kimi&apos;;</span><br><span class=\"line\">console.log(arr.length) // 2</span><br><span class=\"line\">console.log(arr.name) // &apos;kimi&apos;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Object.getOwnPropertyDescriptor(obj, &apos;a&apos;);</span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//  value: 2,</span><br><span class=\"line\">//  writable: true,</span><br><span class=\"line\">//  enumerable: true,</span><br><span class=\"line\">//  configurable: true</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lt-1-gt-writable\"><a href=\"#lt-1-gt-writable\" class=\"headerlink\" title=\"&lt;1&gt; [[writable]]\"></a>&lt;1&gt; [[writable]]</h3><p>表示是否能修改属性的值，默认值是true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class=\"line\">  value: 2,</span><br><span class=\"line\">  writable: false, // 不可写</span><br><span class=\"line\">  configurable: true,</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.a = 3; // 严格模式下会报错，非严格模式下会忽略</span><br><span class=\"line\">obj.a // 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lt-2-gt-configurable-默认值true\"><a href=\"#lt-2-gt-configurable-默认值true\" class=\"headerlink\" title=\"&lt;2&gt; [[configurable]] 默认值true\"></a>&lt;2&gt; [[configurable]] 默认值true</h3><p>是否可以通过defineProperty来配置对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class=\"line\">  value: 2,</span><br><span class=\"line\">  writable: true, </span><br><span class=\"line\">  configurable: false, // 不可配置</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.a = 3; // 仍然可以修改属性值</span><br><span class=\"line\">obj.a // 3</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class=\"line\">  value: 2,</span><br><span class=\"line\">  writable: true, </span><br><span class=\"line\">  configurable: true, // 不管什么模式都会报错</span><br><span class=\"line\">  enumerable: true,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>如果使用Object.defineProperty创建新属性但是不填写配置，writable、configurable、enumerable默认都是false。</strong></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(obj, &apos;a&apos;, &#123;&#125;)</span><br><span class=\"line\">Object.getOwnPropertyDescriptor(obj, &apos;a&apos;);</span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//  value: undefined,</span><br><span class=\"line\">//  writable: false,</span><br><span class=\"line\">//  enumerable: false,</span><br><span class=\"line\">//  configurable: false</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>如果设置了configurable是false。仍然可以将writable的值从true设置为false,但是不可以从false设置为true。</strong><br><strong>如果设置了configurable是false，不可以使用delete删除属性</strong></p>\n</blockquote>\n<h3 id=\"lt-3-gt-value-默认值undefined\"><a href=\"#lt-3-gt-value-默认值undefined\" class=\"headerlink\" title=\"&lt;3&gt; [[value]] 默认值undefined\"></a>&lt;3&gt; [[value]] 默认值undefined</h3><p>包含这个属性的数据值</p>\n<h3 id=\"lt-4-gt-enumerable-默认值true\"><a href=\"#lt-4-gt-enumerable-默认值true\" class=\"headerlink\" title=\"&lt;4&gt; [[enumerable]] 默认值true\"></a>&lt;4&gt; [[enumerable]] 默认值true</h3><p>是否可以for in、object.keys、 JSON.stringify递归出来</p>\n<h2 id=\"访问描述符\"><a href=\"#访问描述符\" class=\"headerlink\" title=\"访问描述符\"></a>访问描述符</h2><h3 id=\"get-set\"><a href=\"#get-set\" class=\"headerlink\" title=\"[[get]] [[set]]\"></a>[[get]] [[set]]</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;;</span><br><span class=\"line\">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class=\"line\">  get: function() &#123;</span><br><span class=\"line\">    return this._a;  </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: function(val) &#123;</span><br><span class=\"line\">    this._a = val;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  get a() &#123;</span><br><span class=\"line\">     return this._a;  </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set a(val) &#123;</span><br><span class=\"line\">    this._a = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>以上两种都会在对象中创建一个不包含值的属性，自动调用get、set函数。如果设置了set、get则会忽略value和enumerable配置</strong></p>\n</blockquote>\n<h2 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h2><h3 id=\"lt-1-gt-设置writable、configurable为false\"><a href=\"#lt-1-gt-设置writable、configurable为false\" class=\"headerlink\" title=\"&lt;1&gt; 设置writable、configurable为false\"></a>&lt;1&gt; 设置writable、configurable为false</h3><p>设置writable、configurable为false就可以创建一个真正的常量属性，不可修改、重定义、删除</p>\n<h3 id=\"lt-2-gt-Object-preventExtensions-不可扩展\"><a href=\"#lt-2-gt-Object-preventExtensions-不可扩展\" class=\"headerlink\" title=\"&lt;2&gt; Object.preventExtensions()  不可扩展\"></a>&lt;2&gt; Object.preventExtensions()  不可扩展</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Object.preventExtensions(obj) ; // 不可以添加新属性，并且保留已有属性</span><br><span class=\"line\">obj.b = 3 ;</span><br><span class=\"line\">obj.b // undefined</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lt-3-gt-Object-seal-密封\"><a href=\"#lt-3-gt-Object-seal-密封\" class=\"headerlink\" title=\"&lt;3&gt; Object.seal()  密封\"></a>&lt;3&gt; Object.seal()  密封</h3><p>会在现有对象身上调用Object.preventExtensions，并把所有属性标记为configurable为false</p>\n<blockquote>\n<p><strong>不能添加新属性，也不能重新配置或者删除现有属性。<code>可以</code>修改现有的值</strong></p>\n</blockquote>\n<h3 id=\"lt-4-gt-Object-freeze-冻结\"><a href=\"#lt-4-gt-Object-freeze-冻结\" class=\"headerlink\" title=\"&lt;4&gt; Object.freeze()  冻结\"></a>&lt;4&gt; Object.freeze()  冻结</h3><p>会在现有对象身上调用Object.seal，并且把所有属性标记为writable为false</p>\n<blockquote>\n<p><strong>不能添加新属性，也不能重新配置或者删除现有属性。<code>不可以</code>修改现有的值</strong></p>\n</blockquote>\n<h2 id=\"存在性\"><a href=\"#存在性\" class=\"headerlink\" title=\"存在性\"></a>存在性</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.a // undefined</span><br><span class=\"line\">obj.b // undefined</span><br><span class=\"line\">都是undefined，如何来区分哪个为obj的属性呢？</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty()\"></a>hasOwnProperty()</h3><blockquote>\n<p><strong>hasOwnProperty只会判断自身是否有属性。in 操作符会检查属性是否存在原型中。</strong></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 in [1,2]  // false 判断的是key 数组的key是下标 0,1</span><br></pre></td></tr></table></figure>\n\n","categories":["前端技术"],"tags":["javascript基础"]},{"title":"javascript基础-作用域&闭包","url":"/2019/07/28/js_bibao/","content":"<h1 id=\"js作用域-amp-闭包\"><a href=\"#js作用域-amp-闭包\" class=\"headerlink\" title=\"js作用域&amp;闭包\"></a>js作用域&amp;闭包</h1><h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>作用域是负责收集并维护由所有声明的变量组成的一系列查询，并且实施一套严格的规则，确定当前执行的代码对这些变量的访问权限 – 《你不知道的javascript》</p>\n</blockquote>\n<p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong></p>\n<h3 id=\"1-作用域链\"><a href=\"#1-作用域链\" class=\"headerlink\" title=\"1 作用域链\"></a>1 作用域链</h3><p>作用域有上下级的关系，会在当前作用域中寻找变量，如果找不到会沿着<code>创建时</code>作用域链一直往上找，直到找到全局作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=1;</span><br><span class=\"line\">function f1()&#123;</span><br><span class=\"line\">   var b=2;   </span><br><span class=\"line\">   function f2()&#123; </span><br><span class=\"line\">     var c=3;</span><br><span class=\"line\">     console.log(a,b,c);</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">f2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1();//1 ,2 ,3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-作用域形成时机\"><a href=\"#2-作用域形成时机\" class=\"headerlink\" title=\"2 作用域形成时机\"></a>2 作用域形成时机</h3><p>作用域是在一个函数创建时就已经形成的，而不是调用时.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a () &#123;</span><br><span class=\"line\">    let b = 2;</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        console.log(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = 222</span><br><span class=\"line\">a(); // 2 而不是222</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>以上的示例调用a函数看似是在全局环境，但是其中的b却没有使用全局的b。而且去寻找定义时的b，没有找到则沿着创建时的作用域链往上找。结果是2</p>\n</blockquote>\n<h3 id=\"3-作用域类别\"><a href=\"#3-作用域类别\" class=\"headerlink\" title=\"3 作用域类别\"></a>3 作用域类别</h3><p><strong>作用域包含全局作用域、函数作用域、和es6中新增的块级作用域。</strong><br>在es6没有出来之前。我们避免变量污染全局的方法是使用函数作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最常见的是使用自执行函数来包裹模块，这样函数中的变量只能在局部作用域中生效</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  // do something</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>而在es6中新增的let和const可以将变量绑定到所在的任意作用域中通常是{…}，为其声明的变量隐式的劫持了所在的块级作用域。 – 《你不知道的javascript》</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">\tsetTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(i) // 10 10 ... 10</span><br><span class=\"line\">\t&#125;, 500)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// es6之前 需要使用自执行函数来创建函数作用域来隔绝变量</span><br><span class=\"line\">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    (function(i)&#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(i) // 10 10 ... 10</span><br><span class=\"line\">\t&#125;, 500)</span><br><span class=\"line\">    &#125;)(i)\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 而es6中直接使用let就可以实现隔绝变量的作用</span><br><span class=\"line\">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">\tsetTimeout(() =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(i) // 0 1 2 ... 9</span><br><span class=\"line\">\t&#125;, 500)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-提升\"><a href=\"#4-提升\" class=\"headerlink\" title=\"4 提升\"></a>4 提升</h3><p>代码被执行前会有声明提升的过程。只有声明本身会被提升，任何作用域都会进行提升操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tconsole.log(a);</span><br><span class=\"line\">\tvar a = 2;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">实际上被解析成如下：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        var a;</span><br><span class=\"line\">\tconsole.log(a);</span><br><span class=\"line\">\ta = 2;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>let和const声明不会被提升，但是不代表这个作用域中不会进行提升操作。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    console.log(a);  //  ReferenceError</span><br><span class=\"line\">    let a = 2;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数的提升是优先于变量的</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();  // 1 打印出来的是1 而不是2</span><br><span class=\"line\">var foo;</span><br><span class=\"line\">function foo () &#123;console.log(1)&#125; </span><br><span class=\"line\">foo = function() &#123;console.log(2)&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><h3 id=\"1-构造函数中this\"><a href=\"#1-构造函数中this\" class=\"headerlink\" title=\"1 构造函数中this\"></a>1 构造函数中this</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Kimi() &#123;</span><br><span class=\"line\">    this.name = &apos;kimi&apos;</span><br><span class=\"line\">    console.log(this)  // &apos;kimi&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Kimi </span><br><span class=\"line\"></span><br><span class=\"line\">如何直接执行Kimi() this指向window</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-函数作为对象的一个属性\"><a href=\"#2-函数作为对象的一个属性\" class=\"headerlink\" title=\"2 函数作为对象的一个属性\"></a>2 函数作为对象的一个属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let kimi = &#123;</span><br><span class=\"line\">\tname : &apos;kimi&apos;,</span><br><span class=\"line\">\tsay: function() &#123;</span><br><span class=\"line\">\t\tconsole.log(this.name) // &apos;kimi&apos;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">kimi.say()  // 这样调用打印的是‘kimi’</span><br><span class=\"line\"></span><br><span class=\"line\">如果不作为属性调用</span><br><span class=\"line\">let  a = kimi.say;</span><br><span class=\"line\">a(); // 这样调用打印的是window</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用call和apply\"><a href=\"#3-使用call和apply\" class=\"headerlink\" title=\"3 使用call和apply\"></a>3 使用call和apply</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let kimi = &#123;</span><br><span class=\"line\">    name : &apos;kimi&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let say = function() &#123;</span><br><span class=\"line\">    console.log(this.name)  // &apos;kimi&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">say.call(kimi);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-全局\"><a href=\"#4-全局\" class=\"headerlink\" title=\"4 全局\"></a>4 全局</h3><p>全局中的this一直指向window</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = &apos;kimi&apos;;</span><br><span class=\"line\">let say = function() &#123;</span><br><span class=\"line\">    console.log(this);  // window</span><br><span class=\"line\">    console.log(this.name);  // &apos;kimi&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">say();</span><br></pre></td></tr></table></figure>\n\n<p><strong>有以下情况：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let kimi = &#123;</span><br><span class=\"line\">\tname : &apos;kimi&apos;,</span><br><span class=\"line\">\tsay: function() &#123;</span><br><span class=\"line\">\t\tfunction a () &#123;</span><br><span class=\"line\">                    console.log(this.name)  // &apos;undefined&apos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">kimi.say();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数a虽然是在kimi.say内部定义的，但是它仍然是一个普通的函数，this仍然指向window。如果需要重新指向kimi则需要使用箭头函数或者用let that = this;保存引用</p>\n</blockquote>\n<h3 id=\"5-this的用途\"><a href=\"#5-this的用途\" class=\"headerlink\" title=\"5 this的用途\"></a>5 this的用途</h3><p>this可以动态的绑定执行的对象，起到复用代码的作用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.extend = jQuery.fn.extend = function() &#123;</span><br><span class=\"line\">    target = this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。<br>执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。</p>\n</blockquote>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在一个函数内部定义的另一个函数，当内部函数在包裹他的函数之外被执行时，就会形成闭包。同时内部函数仍然可以访问到包裹函数中的局部变量与函数。<br><strong>闭包的两个常见用途</strong></p>\n<h3 id=\"1-函数作为返回值\"><a href=\"#1-函数作为返回值\" class=\"headerlink\" title=\"1. 函数作为返回值\"></a>1. 函数作为返回值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">封装变量 避免全局中被修改 ，并且记录状态。状态不会销毁丢失</span><br><span class=\"line\">function isFirst() &#123;</span><br><span class=\"line\">\tvar _list = [];</span><br><span class=\"line\">\treturn function(id) &#123;</span><br><span class=\"line\">\t\tif(_list.includes(id)) &#123;</span><br><span class=\"line\">\t\t\treturn false</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t_list.push(id)</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var first = isFirst()</span><br><span class=\"line\">first(10) // true</span><br><span class=\"line\">first(10) // false</span><br><span class=\"line\">first(20) // true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-函数作为参数\"><a href=\"#2-函数作为参数\" class=\"headerlink\" title=\"2. 函数作为参数\"></a>2. 函数作为参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function wait(message) &#123;</span><br><span class=\"line\">    setTimeout(function timer() &#123;</span><br><span class=\"line\">        console.log(message);</span><br><span class=\"line\">    &#125;, 1000) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(&apos;hello&apos;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>timer  函数传递给setTimeout(),<code>timer就具有了涵盖wait()作用域的闭包，</code>因此保有对变量message的引用，等到1000回调执行后，wait的内部作用域不会消失</p>\n</blockquote>\n<p><strong>在定时器、事件监听器、Ajax请求、跨窗口通信、webworker、或者其他的异步或者同步的任务中，只要使用了回调函数，实际上就在使用闭包。</strong></p>\n","categories":["前端技术"],"tags":["javascript基础"]},{"title":"javascript基础-跨域和解决跨域的方法","url":"/2019/07/26/js_cors/","content":"<h1 id=\"js跨域\"><a href=\"#js跨域\" class=\"headerlink\" title=\"js跨域\"></a>js跨域</h1><h2 id=\"1-同源策略\"><a href=\"#1-同源策略\" class=\"headerlink\" title=\"1.同源策略\"></a>1.同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>\n<p>同源策略限制内容有：<br>Cookie、LocalStorage、IndexedDB 等存储性内容<br>DOM 节点<br>AJAX 请求发送后，结果被浏览器拦截了</p>\n<p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>\n<h2 id=\"2-常见跨域场景\"><a href=\"#2-常见跨域场景\" class=\"headerlink\" title=\"2.常见跨域场景\"></a>2.常见跨域场景</h2><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p>\n<p><img src=\"/images/cors.png\" alt=\"cors.png\"></p>\n<h2 id=\"3-实现跨域的九种方式\"><a href=\"#3-实现跨域的九种方式\" class=\"headerlink\" title=\"3. 实现跨域的九种方式\"></a>3. 实现跨域的九种方式</h2><h3 id=\"1-gt-jsonp\"><a href=\"#1-gt-jsonp\" class=\"headerlink\" title=\"1&gt; jsonp\"></a>1&gt; jsonp</h3><p>有几个标签是允许跨域加载资源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=XXX&gt;</span><br><span class=\"line\">&lt;link href=XXX&gt;</span><br><span class=\"line\">&lt;script src=XXX&gt;</span><br><span class=\"line\">&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链</span><br></pre></td></tr></table></figure>\n\n<p><strong>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击（jsonp请求返回<script></script>）。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">   function kimi(data) &#123;</span><br><span class=\"line\">     console.log(data)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &lt;/script&gt;</span><br><span class=\"line\"> &lt;script src=&quot;https://www.baidu.com/sugrec?prod=pc&amp;wd=8&amp;cb=kimi&quot;&gt;</span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-gt-cors\"><a href=\"#2-gt-cors\" class=\"headerlink\" title=\"2&gt; cors\"></a>2&gt; cors</h3><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n<p>服务端设置了Access-Control-Allow-Origin就开启了CORS通信，表示允许哪个域来访问我。<br>具体需要设置的头部有很多，列举常用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置哪个源可以访问我</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Origin&apos;, origin)</span><br><span class=\"line\">// 允许携带哪个头访问我</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;name&apos;)</span><br><span class=\"line\">// 允许哪个方法访问我</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;)</span><br><span class=\"line\">// 允许携带cookie</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true)</span><br><span class=\"line\">// 预检的存活时间</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Max-Age&apos;, 6)</span><br><span class=\"line\">// 允许返回的头</span><br><span class=\"line\">res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-gt-postMessage\"><a href=\"#3-gt-postMessage\" class=\"headerlink\" title=\"3&gt; postMessage\"></a>3&gt; postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>页面和其打开的新窗口的数据传递</li>\n<li>多窗口之间消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html</span><br><span class=\"line\">  &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      function load() &#123;</span><br><span class=\"line\">        let frame = document.getElementById(&apos;frame&apos;)</span><br><span class=\"line\">        frame.contentWindow.postMessage(&apos;kimi&apos;, &apos;http://localhost:4000&apos;) //发送数据</span><br><span class=\"line\">        window.onmessage = function(e) &#123; //接受返回数据</span><br><span class=\"line\">          console.log(e.data) //yes</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b.html</span><br><span class=\"line\">  window.onmessage = function(e) &#123;</span><br><span class=\"line\">    console.log(e.data) //kimi</span><br><span class=\"line\">    e.source.postMessage(&apos;yes, e.origin)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-gt-http-proxy\"><a href=\"#4-gt-http-proxy\" class=\"headerlink\" title=\"4&gt; http-proxy\"></a>4&gt; http-proxy</h3><p>  一般在使用webpack时webpack-dev-server会加proxy-table来转发请求。因为同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略</p>\n<h3 id=\"5-gt-nginx\"><a href=\"#5-gt-nginx\" class=\"headerlink\" title=\"5&gt; nginx\"></a>5&gt; nginx</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  nginx proxy服务器</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       81;</span><br><span class=\"line\">    server_name  www.domain1.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class=\"line\">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-gt-websocket\"><a href=\"#6-gt-websocket\" class=\"headerlink\" title=\"6&gt; websocket\"></a>6&gt; websocket</h3><p>websocket 是没有跨域限制的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// socket.html</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let socket = new WebSocket(&apos;ws://localhost:3000&apos;);</span><br><span class=\"line\">    socket.onopen = function () &#123;</span><br><span class=\"line\">      socket.send(&apos;kimi1&apos;);//向服务器发送数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    socket.onmessage = function (e) &#123;</span><br><span class=\"line\">      console.log(e.data);//接收服务器返回的数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// server.js</span><br><span class=\"line\">let express = require(&apos;express&apos;);</span><br><span class=\"line\">let app = express();</span><br><span class=\"line\">let WebSocket = require(&apos;ws&apos;);</span><br><span class=\"line\">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class=\"line\">wss.on(&apos;connection&apos;,function(ws) &#123;</span><br><span class=\"line\">  ws.on(&apos;message&apos;, function (data) &#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">    ws.send(&apos;kimi2&apos;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-gt-document-domain\"><a href=\"#7-gt-document-domain\" class=\"headerlink\" title=\"7&gt; document.domain\"></a>7&gt; document.domain</h3><p>该方式只能用于二级域名相同的情况下，比如 video.baidu.com 和 <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> 适用于该方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"> helloa</span><br><span class=\"line\">  &lt;iframe src=&quot;http://video.baidu.com&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    document.domain = &apos;baidu.cn&apos;</span><br><span class=\"line\">    function load() &#123;</span><br><span class=\"line\">      console.log(frame.contentWindow.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b.html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">   hellob</span><br><span class=\"line\">   &lt;script&gt;</span><br><span class=\"line\">     document.domain = &apos;baidu.cn&apos;</span><br><span class=\"line\">     var a = 100;</span><br><span class=\"line\">   &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-gt-window-name\"><a href=\"#8-gt-window-name\" class=\"headerlink\" title=\"8&gt; window.name\"></a>8&gt; window.name</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<blockquote>\n<p>实现：先在a页面中嵌入c页面，在c页面中写入window.name值, c加载完毕后马上切换成a同源的b页面。等b加载完后可以拿到没有清除的name值</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html(http://localhost:3000/b.html)</span><br><span class=\"line\">  &lt;iframe src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    let first = true</span><br><span class=\"line\">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class=\"line\">    function load() &#123;</span><br><span class=\"line\">      if(first)&#123;</span><br><span class=\"line\">      // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class=\"line\">        let iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class=\"line\">        iframe.src = &apos;http://localhost:3000/b.html&apos;;</span><br><span class=\"line\">        first = false;</span><br><span class=\"line\">      &#125;else&#123;</span><br><span class=\"line\">      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span><br><span class=\"line\">        console.log(iframe.contentWindow.name);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// c.html(http://localhost:4000/c.html)</span><br><span class=\"line\"> &lt;script&gt;</span><br><span class=\"line\">   window.name = &apos;yes&apos;  </span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-gt-location-hash\"><a href=\"#9-gt-location-hash\" class=\"headerlink\" title=\"9&gt; location.hash\"></a>9&gt; location.hash</h3><blockquote>\n<p>a页面嵌入c页面带给他hash数据，c页面中拿到后，再嵌入和a同源的b页面带入hash数据，b拿到后再设置回a页面的hash中。a中再监听hash变化来获取。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.html</span><br><span class=\"line\">  &lt;iframe src=&quot;http://localhost:4000/c.html#kimi&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    window.onhashchange = function () &#123; //检测hash的变化</span><br><span class=\"line\">      console.log(location.hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b.html</span><br><span class=\"line\"> &lt;script&gt;</span><br><span class=\"line\">   window.parent.parent.location.hash = location.hash </span><br><span class=\"line\">   //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span><br><span class=\"line\"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// c.html</span><br><span class=\"line\">console.log(location.hash);</span><br><span class=\"line\"> let iframe = document.createElement(&apos;iframe&apos;);</span><br><span class=\"line\"> iframe.src = &apos;http://localhost:3000/b.html#yes&apos;;</span><br><span class=\"line\"> document.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>现在业界主流使用解决跨域问题的方案主要是 nginx和cors、jsonp（优势在于可以兼容老版本浏览器，但是只支持get并且不安全），本地开发常用node-proxy的方式做反向代理。其他的方式都不常用。location.hash和window.name都需要有第三方中介。而domain的方式会有域名的限制条件。</p>\n</blockquote>\n","categories":["前端技术"],"tags":["javascript基础"]},{"title":"javascript基础-类型转换","url":"/2019/07/21/js_type_tranform/","content":"<h1 id=\"js类型转换\"><a href=\"#js类型转换\" class=\"headerlink\" title=\"js类型转换\"></a>js类型转换</h1><h2 id=\"1-用于类型转换的valueOf和toString\"><a href=\"#1-用于类型转换的valueOf和toString\" class=\"headerlink\" title=\"1 用于类型转换的valueOf和toString\"></a>1 用于类型转换的valueOf和toString</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\" target=\"_blank\" rel=\"noopener\">valueOf()</a>的意义是，返回这个对象<strong>逻辑上对应的</strong>原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\" target=\"_blank\" rel=\"noopener\">toString()</a>的意义是，返回这个对象的字符串表示。<strong>用一个字符串来描述这个对象的内容。</strong></li>\n</ul>\n<p><strong>基本类型的valueOf会返回自身的原始类型，而Array、Function、Object都返回自身，Date返回时间戳，Error和Math没有valueOf方法</strong></p>\n<h2 id=\"2-用于检测类型的四个js内部方法\"><a href=\"#2-用于检测类型的四个js内部方法\" class=\"headerlink\" title=\"2 用于检测类型的四个js内部方法\"></a>2 用于检测类型的四个js内部方法</h2><p>这4个方法实际上是<a href=\"https://tc39.github.io/ecma262/#sec-type-conversion\" target=\"_blank\" rel=\"noopener\">ECMAScript定义的4个抽象的操作</a>，它们在js内部使用，进行类型转换。我们js的使用者不能直接调用这些函数，但是了解这些函数有利于我们理解js类型转换的原理。</p>\n<ul>\n<li>ToPrimitive ( input [ , PreferredType ] )</li>\n<li>ToBoolean ( argument )</li>\n<li>ToNumber ( argument )</li>\n<li>ToString ( argument )</li>\n</ul>\n<blockquote>\n<p>请区分这里的ToString()和上文谈到的toString()，一个是js引擎内部使用的函数，另一个是定义在对象上的函数。</p>\n</blockquote>\n<h3 id=\"ToPrimitive-input-PreferredType\"><a href=\"#ToPrimitive-input-PreferredType\" class=\"headerlink\" title=\"ToPrimitive ( input [ , PreferredType ] )\"></a>ToPrimitive ( input [ , PreferredType ] )</h3><p>将input转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number 或 String。<strong>如果PreferredType参数是Number</strong>，ToPrimitive这样执行：</p>\n<ol>\n<li>如果input本身就是原始类型，直接返回input。</li>\n<li>调用<strong>input.valueOf()</strong>，如果结果是原始类型，则返回这个结果。</li>\n<li>调用<strong>input.toString()</strong>，如果结果是原始类型，则返回这个结果。</li>\n<li>抛出TypeError异常。</li>\n</ol>\n<p><strong>以下是PreferredType不为Number时的执行顺序。</strong></p>\n<ul>\n<li>如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。</li>\n<li>如果PreferredType参数没有传入<ul>\n<li>如果input是内置的Date类型，PreferredType 视为String</li>\n<li>否则PreferredType 视为 Number – 先调用valueOf 再调用toString</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Date 转换的时候PreferredType 视为String先调用toString。所以console.log(111 + new Date())  // “111Thu Jul 25 2019 22:34:51 GMT+0800 (中国标准时间)”</p>\n</blockquote>\n<blockquote>\n<p><strong>可以看出，ToPrimitive依赖于valueOf和toString的实现。</strong><br><img src=\"/images/to.jpg\" alt=\"toPrimitive.jpg\"></p>\n</blockquote>\n<h3 id=\"ToBoolean-argument\"><a href=\"#ToBoolean-argument\" class=\"headerlink\" title=\"ToBoolean ( argument )\"></a>ToBoolean ( argument )</h3><table>\n<thead>\n<tr>\n<th>Argument Type</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>Return false</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Return false</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>Return argument</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>仅当argument为 +0, -0, or NaN时， return false; 否则一律 return true</td>\n</tr>\n<tr>\n<td>String</td>\n<td>仅当argument是空字符串（长度为0）时， return false; 否则一律 return true</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>Return true</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>Return true</td>\n</tr>\n</tbody></table>\n<p>这些规定都来自<a href=\"https://tc39.github.io/ecma262/#sec-toboolean\" target=\"_blank\" rel=\"noopener\">ECMA的标准</a>，在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。</p>\n<h3 id=\"ToNumber-argument\"><a href=\"#ToNumber-argument\" class=\"headerlink\" title=\"ToNumber ( argument )\"></a>ToNumber ( argument )</h3><table>\n<thead>\n<tr>\n<th>Argument Type</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>Return NaN</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Return +0</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果 argument 为 true, return 1. 如果 argument 为 false, return +0</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>直接返回argument</td>\n</tr>\n<tr>\n<td>String</td>\n<td>将字符串中的内容转化为数字（比如”23”-&gt;23），如果转化失败则返回NaN（比如”23a”-&gt;NaN）</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>抛出 TypeError 异常</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>先<strong>primValue = ToPrimitive(argument, Number)</strong>，再对primValue 使用 ToNumber(primValue)</td>\n</tr>\n</tbody></table>\n<p>由上表可见ToNumber的转化并不总是成功，有时会转化成NaN，有时则直接抛出异常。</p>\n<blockquote>\n<p>所以Number([1,2]) -&gt; 先由ToPrimitive(argument, Number)转换[1,2]  -&gt; valueOf返回本身，再调用toString返回’1,2’ -&gt; 再ToNumber(primValue) 转换为NaN</p>\n</blockquote>\n<h3 id=\"ToString-argument\"><a href=\"#ToString-argument\" class=\"headerlink\" title=\"ToString ( argument )\"></a>ToString ( argument )</h3><table>\n<thead>\n<tr>\n<th>Argument Type</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>Return “undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Return “null”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>如果 argument 为 true, return “true”.如果 argument 为 false, return “false”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>用字符串来表示这个数字</td>\n</tr>\n<tr>\n<td>String</td>\n<td>直接返回 argument</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>抛出 TypeError 异常</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>先primValue = ToPrimitive(argument, hint String)，再对primValue使用ToString(primValue)</td>\n</tr>\n</tbody></table>\n<p><img src=\"/images/tra.png\" alt=\"2.png\"></p>\n<h2 id=\"3-隐式类型转换（自动类型转换）\"><a href=\"#3-隐式类型转换（自动类型转换）\" class=\"headerlink\" title=\"3 隐式类型转换（自动类型转换）\"></a>3 隐式类型转换（自动类型转换）</h2><p>当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。</p>\n<p>例子1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ( !undefined</span><br><span class=\"line\">  &amp;&amp; !null</span><br><span class=\"line\">  &amp;&amp; !0</span><br><span class=\"line\">  &amp;&amp; !NaN</span><br><span class=\"line\">  &amp;&amp; !&apos;&apos;</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // true</span><br></pre></td></tr></table></figure>\n\n<p>例子1：因为在if的括号中，js期望得到boolean的值，所以对括号中每一个值都使用ToBoolean ( argument )，将它们转化成boolean。</p>\n<p>例子2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 * &#123; valueOf: function () &#123; return 5 &#125; &#125;;  //15</span><br></pre></td></tr></table></figure>\n\n<p>例子2：因为在乘号的两端，js期望得到number类型的值，所以对右边的那个对象使用ToNumber ( argument )，得到结果5，再与乘号左边的3相乘。</p>\n<p>例子3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; function returnObject() &#123; return &#123;&#125; &#125;</span><br><span class=\"line\">&gt; 3 * &#123; valueOf: function () &#123; return &#123;&#125; &#125;, toString: function () &#123; return &#123;&#125; &#125; &#125;</span><br><span class=\"line\">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>\n\n<p>例子3：调用ToNumber ( argument )的过程中，调用了ToPrimitive ( input , Number )，因为在ToPrimitive中valueOf和toString都没有返回原始类型，所以抛出异常。</p>\n<h3 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h3><p>符号’+’是一个比较棘手的一个符号，因为它既可以表示“算数加法”，也可以表示“字符串拼接”。<br>简单理解版本：只要’+’两端的任意一个操作数是字符串，那么这个’+’就表示字符串拼接，否则表示算数加法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12+3</span><br><span class=\"line\">// 15</span><br><span class=\"line\">12+&apos;3&apos;</span><br><span class=\"line\">// &quot;123&quot;</span><br></pre></td></tr></table></figure>\n\n<p>原理理解版本：根据<a href=\"https://tc39.github.io/ecma262/#sec-addition-operator-plus\" target=\"_blank\" rel=\"noopener\">ECMAScript的定义</a>，对’+’运算的求值按照以下过程：</p>\n<ol>\n<li>令lval = 符号左边的值，rval = 符号右边的值</li>\n<li>令lprim = ToPrimitive(lval)，rprim = ToPrimitive(rval)</li>\n<li><ul>\n<li>如果lprim和rprim中<strong>有任意一个为string类型</strong>，将ToString(lprim)和ToString(rprim)的结果做字符串拼接</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>否则，将ToNumber(lprim)和ToNumber(rprim)的结果做算数加法</li>\n</ul>\n<p>根据这个原理可以解释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]+[]</span><br><span class=\"line\">//  &quot;&quot;</span><br><span class=\"line\">// 提示：ToPrimitive([])返回空字符串</span><br><span class=\"line\"></span><br><span class=\"line\">[] + &#123;&#125;</span><br><span class=\"line\">//  &quot;[object Object]&quot;</span><br><span class=\"line\">//  提示：ToPrimitive(&#123;&#125;)返回&quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">123 + &#123; toString: function () &#123; return &quot;def&quot; &#125; &#125;</span><br><span class=\"line\">//  &quot;123def&quot;</span><br><span class=\"line\">//  提示：ToPrimitive(加号右边的对象)返回&quot;def&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#125; + []</span><br><span class=\"line\">//  0</span><br><span class=\"line\">// 结果不符合我们的预期：&quot;[object Object]&quot;</span><br><span class=\"line\">// 提示：在Chrome中，符号左边的&#123;&#125;被解释成了一个语句块，而不是一个对象</span><br><span class=\"line\">// 注意在别的执行引擎上可能会将&#123;&#125;解释成对象</span><br><span class=\"line\">//  这一行等价于&apos;+[]&apos;</span><br><span class=\"line\">// &apos;+anyValue&apos;等价于Number(anyValue)</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123;&#125;) + []</span><br><span class=\"line\">//  &quot;[object Object]&quot;</span><br><span class=\"line\">// 加上括号以后，&#123;&#125;被解释成了一个对象，结果符合我们的预期了</span><br></pre></td></tr></table></figure>\n\n<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;a&apos; + + &apos;b&apos; // -&gt; &quot;aNaN&quot;</span><br></pre></td></tr></table></figure>\n\n<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。相当于调用ToNumber方法</p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><ol>\n<li>如果是对象，就通过 toPrimitive 转换对象</li>\n<li>如果是字符串，就通过 unicode 字符索引来比较<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  valueOf() &#123;</span><br><span class=\"line\">    return 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;1&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a &gt; -1 // true</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"双等\"><a href=\"#双等\" class=\"headerlink\" title=\"== 双等\"></a>== 双等</h3><blockquote>\n<p>xy都为Null或undefined,return true; 一方为Null或undefined，return false<br>x或y为NaN, return false;<br>如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较<br>如果存在Object，转换为原始值，再比较</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;0&quot; == null; // false</span><br><span class=\"line\">&quot;0&quot; == undefined; // false</span><br><span class=\"line\">&quot;0&quot; == false; // true ！</span><br><span class=\"line\">&quot;0&quot; == NaN; // false</span><br><span class=\"line\">&quot;0&quot; == 0; // true</span><br><span class=\"line\">&quot;0&quot; == &quot;&quot;; // false</span><br><span class=\"line\">false == null; // false</span><br><span class=\"line\">false == undefined; // false</span><br><span class=\"line\">false == NaN; // false</span><br><span class=\"line\">false == 0; // true ！</span><br><span class=\"line\">false == &quot;&quot;; // true ！</span><br><span class=\"line\">false == []; // true ！</span><br><span class=\"line\">false == &#123;&#125;; // false</span><br><span class=\"line\">&quot;&quot; == null; // false</span><br><span class=\"line\">&quot;&quot; == undefined; // false</span><br><span class=\"line\">&quot;&quot; == NaN; // false</span><br><span class=\"line\">&quot;&quot; == 0; // true ！</span><br><span class=\"line\">&quot;&quot; == []; // true ！</span><br><span class=\"line\">&quot;&quot; == &#123;&#125;; // false</span><br><span class=\"line\">0 == null; // false</span><br><span class=\"line\">0 == undefined; // false</span><br><span class=\"line\">0 == NaN; // false</span><br><span class=\"line\">0 == []; // true ！</span><br><span class=\"line\">0 == &#123;&#125;; // false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-显式类型转换（强制类型转换）\"><a href=\"#4-显式类型转换（强制类型转换）\" class=\"headerlink\" title=\"4 显式类型转换（强制类型转换）\"></a>4 显式类型转换（强制类型转换）</h2><p>程序员显式调用Boolean(value)、Number(value)、String(value)完成的类型转换，叫做显示类型转换。<br>我们在文章的前面说过new Boolean(value)、new Number(value)、new String(value)传入各自对应的原始类型的值，可以实现“装箱”——将原始类型封装成一个对象。其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean(&apos;sdfsd&apos;);  //  true</span><br><span class=\"line\">Number(&quot;23&quot;);  //  23</span><br><span class=\"line\">String(&#123;a:24&#125;);  //  &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n<p>其实这三个函数用于类型转换的时候，调用的就是js内部的<code>ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )</code>方法！<br>Number()比parseInt parseFloat严格。parseInt parseFloat会只截取数字转换</p>\n<p>这里解释一下<code>String({a:24}); // &quot;[object Object]&quot;</code>的过程：</p>\n<ul>\n<li>执行String({a:24})<ul>\n<li>执行js内部函数ToString ( {a:24} )<ul>\n<li>执行<code>primValue = ToPrimitive({a:24}, hint String)</code><ol>\n<li>因为{a:24}不是原始类型，进入下一步。</li>\n<li>在ToPrimitive内调用({a:24}).toString()，返回了原始值”[object Object]”，因此直接返回这个字符串，ToPrimitive后面的步骤不用进行下去了。</li>\n</ol>\n</li>\n<li>primValue被赋值为ToPrimitive的返回值：”[object Object]”</li>\n<li>执行js内部函数ToString ( “[object Object]” )，返回”[object Object]”</li>\n<li>返回”[object Object]”</li>\n</ul>\n</li>\n<li>返回”[object Object]”</li>\n</ul>\n</li>\n<li>返回”[object Object]”</li>\n</ul>\n<blockquote>\n<p>为了防止出现意料之外的结果，<strong>最好在不确定的地方使用显式类型转换</strong>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">\tvalueOf() &#123;</span><br><span class=\"line\">\t\treturn 2</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttoString()&#123;</span><br><span class=\"line\">\t\treturn []</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">String(obj2)  // &apos;2&apos;</span><br><span class=\"line\">2 + obj2   // 4</span><br></pre></td></tr></table></figure>\n\n<p>当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  valueOf() &#123;</span><br><span class=\"line\">    return 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;1&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  [Symbol.toPrimitive]() &#123;</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">1 + a // =&gt; 3</span><br></pre></td></tr></table></figure>\n\n<p>parseInt()<br>   parseInt只会转换字符串。如果传入的不是字符串会先转换成字符串再进行parse。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">\tvalueOf:function() &#123;return &apos;2px&apos;&#125;,</span><br><span class=\"line\">\ttoString: function() &#123;return []&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">parseInt(obj)  // 2  如果不是字符串会先根据ToString规则转换成字符串。再去转换</span><br><span class=\"line\"></span><br><span class=\"line\">parseInt(1/0, 19) // 18  =&gt; 1/0转换成字符串为Infinity 。而有效数字范围是0-9 a-i 所以第一位为I 代表18。n超出19的范围了所以只有18返回</span><br><span class=\"line\">parseInt(0.0000008) // 8 =&gt; 8e+7  6个0转换成字符串会转换成指数</span><br><span class=\"line\">parseInt(0.000008) // 0 =&gt; 0.000008 </span><br><span class=\"line\">parseInt(false, 16) // 250 =&gt; &apos;false&apos; =&gt; &apos;fa&apos;在16进制下有效</span><br><span class=\"line\">parseInt(function()&#123;...&#125;, 16) // 15 =&gt; &apos;f&apos;在16进制下有效</span><br></pre></td></tr></table></figure>\n\n<p>如果不填写第二个参数，则会根据传入的值来判断是什么进制，填写了代表转换成多少进制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;0x10&apos;)  // 16</span><br><span class=\"line\">parseInt(&apos;103&apos;, 2)  // 2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>tip: </p>\n<ol>\n<li>~运算符可以表示 -(x+1)   : ~2 =&gt; -3  ~-1 =&gt; 0  根据这个特性。可以对-1进行特殊判断。比如indexof时 。if( ~a. indexof(‘bbb’) )  表示如果是-1就会返回false。</li>\n<li>3.2 | 0  =&gt; 3;   -6.7 | 0  =&gt; -6</li>\n</ol>\n</blockquote>\n","categories":["前端技术"],"tags":["javascript基础"]},{"title":"javascript基础-数据类型","url":"/2019/07/21/js_type/","content":"<h1 id=\"js-数据类型\"><a href=\"#js-数据类型\" class=\"headerlink\" title=\"js 数据类型\"></a>js 数据类型</h1><p>  js中有六种原始类型：</p>\n<ul>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>string</li>\n<li>symbol<br>一种引用类型</li>\n<li>object</li>\n</ul>\n<p>引用类型和基本类型有什么区别，以及深浅拷贝之类就暂时不表了。</p>\n<blockquote>\n<p><code>注意点：</code></p>\n<ol>\n<li>undefined和not defined是不同的 。undefined代表的是定义了但是没有赋值，not defined表示没有定义。但是typeof 都返回undefined。</li>\n<li>js中的string是不可变的，他的成员函数不会改变原值，而是创建并返回一个新的字符串。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = a.toUpperCase();</span><br><span class=\"line\">a === c // false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-typeof\"><a href=\"#1-typeof\" class=\"headerlink\" title=\"1 typeof\"></a>1 typeof</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof false // boolean</span><br><span class=\"line\">typeof null // object</span><br><span class=\"line\">typeof undefined // undefined</span><br><span class=\"line\">typeof 2 // number</span><br><span class=\"line\">typeof NaN // number</span><br><span class=\"line\">typeof Infinity // number</span><br><span class=\"line\">typeof &apos;kimi&apos; // string</span><br><span class=\"line\">typeof Symbol(&apos;kimi&apos;) // symbol</span><br><span class=\"line\"></span><br><span class=\"line\">typeof Date // funtion</span><br><span class=\"line\">typeof [2,2,3] // object</span><br><span class=\"line\">typeof &#123;a:1&#125; // object</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>使用typeof检测基本类型基本可以正确的判断出类型的，但是判断引用类型时就没有那么准确了。因为数组、对象、函数实际上都是引用类型。但function对象和普通的对象相比，其内部有一个<strong>[[call]]</strong>方法，用来表示这个对象是可调用的。所以返回时function。实际<strong>函数就是一个可调用对象。</strong>如果要准确的判断各个引用类型就需要使用<strong>instanceof</strong>。</li>\n<li>null返回object。这是js的一个bug，js最初版本使用的是32位系统，为了性能考虑用低位存储变量的类型信息，<strong>000</strong>开头表示对象，然后null为<strong>全零</strong>。所以返回object。现在内部类型判断代码已经改变。但是这个bug仍然在。<strong>所以null其实算做基本类型</strong></li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null instanceof object // false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-字面量、String-、new-String\"><a href=\"#2-字面量、String-、new-String\" class=\"headerlink\" title=\"2 字面量、String()、new String()\"></a>2 字面量、String()、new String()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var abc = &apos;abc&apos;,</span><br><span class=\"line\">    str1 = String(abc),</span><br><span class=\"line\">    str2 = new String(abc);</span><br><span class=\"line\">//判断下面输出</span><br><span class=\"line\">str1 === abc   //true</span><br><span class=\"line\">str2 === abc   //false</span><br><span class=\"line\">typeof str1 // string</span><br><span class=\"line\">typeof str2 // object</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>String() 和 字面量的方式返回的都是基本类型，String() 用来做类型转换<br>  而new String()返回object</p>\n</blockquote>\n<p><strong>Q:为什么 ‘kimi’基本类型可以去调用length或者toString方法和属性呢？</strong></p>\n<blockquote>\n<p> 在这里，只要引用了字符串’kimi’的属性或方法，<strong>JavaScript就会将字符串值通过调用new String（s）的方式转换成对象，这个对象继承了字符串的方法，并用来处理属性的作用。一旦属性引用结束，这个新创建的对象就会销毁</strong>（其实在实现上并不一定创建和销毁这个临时对象，然而整个过程看起来就是这样的）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类似代码：</span><br><span class=\"line\">var a1 = new String(&quot;kimi&quot;);</span><br><span class=\"line\">var a2 = a1.substring(0);</span><br><span class=\"line\">a1 = null;</span><br><span class=\"line\">console.log(a2);  // kimi</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>存取字符串，数字或布尔值的属性时创建的临时对象称作包装对象</strong><br>同字符串一样，数字和布尔值也具有各自的方法：通过Number和Boolean构造函数创建一个临时对象，这些方法的调用均是来自这个临时对象.null和undefined没有包装对象：访问它们的属性会造成一个错误。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = “test”;</span><br><span class=\"line\">s.len = 4; </span><br><span class=\"line\">console.log(s.len); // undefined</span><br><span class=\"line\">// 由于包装对象使用完毕会自己销毁，所以添加的属性也读取不到。</span><br></pre></td></tr></table></figure>\n\n<p><strong>Q:为什么2.toString()会报错？</strong></p>\n<blockquote>\n<p>在这里的 . 它既可以理解为小数点，也可以理解为对方法的调用，按照规范，解释器把它判断为一个小数点。 2.toString() 在解释器看来其实是：(2.)toString();<br>如果想解决可以使用如下方式都可以正确输出</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2..toString()</span><br><span class=\"line\">(2).toString();</span><br><span class=\"line\">2 .toString();  //加个空格</span><br><span class=\"line\">2.0.toString();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-准确类型判断方法\"><a href=\"#3-准确类型判断方法\" class=\"headerlink\" title=\"3 准确类型判断方法\"></a>3 准确类型判断方法</h2><h3 id=\"1-instanceof-配合-typeof\"><a href=\"#1-instanceof-配合-typeof\" class=\"headerlink\" title=\"1. instanceof 配合 typeof\"></a>1. instanceof 配合 typeof</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person = function() &#123;&#125;</span><br><span class=\"line\">const p1 = new Person()</span><br><span class=\"line\">p1 instanceof Person</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;hello&apos;</span><br><span class=\"line\">str instanceof String // false</span><br><span class=\"line\">str.__proto__ // String</span><br><span class=\"line\">// str字面量有__proto__属性是因为转换成包装对象。但是本身是个基本类型，使用不了instanceof</span><br><span class=\"line\"></span><br><span class=\"line\">let str1 = new String(&apos;hello&apos;)</span><br><span class=\"line\">str1 instanceof String // true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>综上如果是基本类型可以使用typeof，引用类型使用instanceof</p>\n</blockquote>\n<h4 id=\"2-Object-prototype-toString-call\"><a href=\"#2-Object-prototype-toString-call\" class=\"headerlink\" title=\"2. Object.prototype.toString.call()\"></a>2. Object.prototype.toString.call()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(2) // [object Number]</span><br><span class=\"line\">Object.prototype.toString.call(&apos;kimi&apos;) // [object String]</span><br><span class=\"line\">Object.prototype.toString.call(true) // [object Boolean]</span><br><span class=\"line\">Object.prototype.toString.call(Symbol(&apos;kimi&apos;)) // [object Symbol]</span><br><span class=\"line\">Object.prototype.toString.call(new Date()) // [object Date]</span><br><span class=\"line\">Object.prototype.toString.call(new RegExp()) // [object RegExp]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Object.prototype.toString.call()、toString()、 toString.call()</strong></p>\n<blockquote>\n<p>所有的对象最后都会继承Object.prototype.toString这个方法。而在每个子类中都会改写这个方法。Array、Function的原型上都已经改写了这个方法。每个对象上调用toString方法时会先调用自身的toString方法，如果找不到会沿着原型链往上找，如果一直没找到最终会找到Object.prototype.toString这个方法</p>\n</blockquote>\n<p><strong>具体看下每个对象调用toString方法的结果：</strong><br>1 对象 object</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a: 1&#125;;</span><br><span class=\"line\">obj.toString(); // &quot;[object Object]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(obj); // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Object.prototype.toString()  在toString方法被调用时,会执行下面的操作步骤</p>\n<ol>\n<li>获取this对象的[[Class]]属性的值。</li>\n<li>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串。  </li>\n<li>返回第二步的操作结果Result(2)。<br>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的: <strong>内部属性 描述 [[Class]] 一个字符串值,表明了该对象的类型。</strong><blockquote>\n<p>其过程简单说来就是：<strong>1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。</strong></p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p>那么同时我们可以想是否任何对象object都可以通过this绑定调用Object.prototype.toString()方法，这样可以准确的检测出类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(&#123;&#125;); // [object Object]</span><br><span class=\"line\">Object.prototype.toString.call([]); // [object Array]</span><br><span class=\"line\">Object.prototype.toString.call(function()&#123;&#125;); // [object Function]</span><br><span class=\"line\">Object.prototype.toString.call(&apos;&apos;); // [object String]</span><br><span class=\"line\">Object.prototype.toString.call(1); // [object Number]</span><br><span class=\"line\">Object.prototype.toString.call(true); // [object Boolean]</span><br><span class=\"line\">Object.prototype.toString.call(null); // [object Null]</span><br><span class=\"line\">Object.prototype.toString.call(undefined); // [object Undefined]</span><br><span class=\"line\">// 相当于Object.prototype.toString.call(undefined);</span><br><span class=\"line\">Object.prototype.toString.call(); // [object Undefined] </span><br><span class=\"line\">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class=\"line\">Object.prototype.toString.call(/at/); // [object RegExp]</span><br><span class=\"line\"></span><br><span class=\"line\">// toString() 方法能识别以下类型是因为引擎为它们设置好了 toStringTag 标签</span><br><span class=\"line\">Object.prototype.toString.call(new Map());       // &quot;[object Map]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(function* () &#123;&#125;); // &quot;[object GeneratorFunction]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(Promise.resolve()); // &quot;[object Promise]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 自己创建的类不能识别，toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class=\"line\">class ValidatorClass &#123;&#125;</span><br><span class=\"line\">Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Object]&quot;</span><br><span class=\"line\">// 可以加上 toStringTag 属性让他识别</span><br><span class=\"line\">class ValidatorClass &#123;</span><br><span class=\"line\">  get [Symbol.toStringTag]() &#123;</span><br><span class=\"line\">    return &quot;Validator&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Validator]&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>因为Object是所有子类的父类，所以任何类型的对象object都可以通过this绑定调用Object.prototype.toString()方法，返回该对象的字符串表示</strong></p>\n<p>2 数组 array<br>toString()：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果是多维数组会递归调用toString()方法</span><br><span class=\"line\">var array = [1, &apos;s&apos;, true, &#123;a: 2&#125;];</span><br><span class=\"line\">array.toString();//&quot;1,s,true,[object Object]&quot;</span><br><span class=\"line\">Array.prototype.toString.call(array);//&quot;1,s,true,[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n<p>那么别的对象是否可以调用数组的toString方法呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.toString.call(&#123;&#125;); // [object Object]</span><br><span class=\"line\">Array.prototype.toString.call(function()&#123;&#125;) // [object Function]</span><br><span class=\"line\">Array.prototype.toString.call(1) // [object Number]</span><br><span class=\"line\">Array.prototype.toString.call(&apos;&apos;) // [object String]</span><br><span class=\"line\">Array.prototype.toString.call(true) // [object Boolean]</span><br><span class=\"line\">Array.prototype.toString.call(/s/) // [object RegExp]</span><br><span class=\"line\">// 特殊</span><br><span class=\"line\">&lt;!--以下都是 Cannot convert undefined or null to object at toString--&gt;</span><br><span class=\"line\">Array.prototype.toString.call(); // 相当于Array.prototype.toString.call(undefined)</span><br><span class=\"line\">Array.prototype.toString.call(undefined);</span><br><span class=\"line\">Array.prototype.toString.call(null);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>数组对象通过this绑定调用Array.prototype.toString()方法，返回数组值的字符串拼接<br>非数组对象通过this绑定调用Array.prototype.toString()方法，返回的是该对象的字符串表示<br>另外null和undefined不可以通过绑定调用Array.prototype.toString()方法。</p>\n</blockquote>\n<p>3 函数 function<br>toString()：返回函数的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    console.log(&apos;function&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.toString();</span><br><span class=\"line\">&lt;!--&quot;function foo()&#123;--&gt;</span><br><span class=\"line\">&lt;!--    console.log(&apos;function&apos;);--&gt;</span><br><span class=\"line\">&lt;!--&#125;&quot;--&gt;</span><br><span class=\"line\">Function.prototype.toString.call(foo);</span><br><span class=\"line\">&lt;!--&quot;function foo()&#123;--&gt;</span><br><span class=\"line\">&lt;!--    console.log(&apos;function&apos;);--&gt;</span><br><span class=\"line\">&lt;!--&#125;&quot;--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// Object Function Array本质都是构造函数</span><br><span class=\"line\">Object.toString();</span><br><span class=\"line\">// &quot;function Object() &#123; [native code] &#125;&quot;</span><br><span class=\"line\">Function.toString();</span><br><span class=\"line\">// &quot;function Function() &#123; [native code] &#125;&quot;</span><br><span class=\"line\">Array.toString();</span><br><span class=\"line\">// &quot;function Array() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>非函数对象是否可以使用函数的toString方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.toString.call(&#123;&#125;)</span><br><span class=\"line\">&lt;!--Function.prototype.toString requires that &apos;this&apos; be a Function--&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除了上述提到的Object和Array两种情况，其他类型都不支持非自身实例通过this绑定调用该Object子类原型对象上的toString()方法，这说明它们在重写toString()方法时，明确限定了调用该方法的对象类型，非自身对象实例不可调用。所以，<strong>一般我们只使用Object.prototype.toString.call/apply()方法。</strong></p>\n</blockquote>\n<p>4 日期 Date<br>toString()：返回带有时区信息的日期和时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var date = new Date();</span><br><span class=\"line\">date.toString();</span><br><span class=\"line\">//&quot;Fri May 11 2019 14:55:43 GMT+0800 (中国标准时间)&quot;</span><br><span class=\"line\">Date.prototype.toString.call(date);</span><br><span class=\"line\">//&quot;Fri May 11 2019 14:55:43 GMT+0800 (中国标准时间)&quot;</span><br></pre></td></tr></table></figure>\n\n<p>5 正则 RegExp<br>toString()：返回正则表达式的字面量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /cat/g;</span><br><span class=\"line\">re.toString();// &quot;/cat/g&quot;</span><br><span class=\"line\">RegExp.prototype.toString.call(re);// &quot;/cat/g&quot;</span><br></pre></td></tr></table></figure>\n\n<p>6 字符串 string<br>toString()：返回字符串的一个副本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;a&quot;;</span><br><span class=\"line\">str.toString(); //&quot;a&quot;</span><br><span class=\"line\">String.prototype.toString.call(str); //&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p>7 数字 number<br>toString()：返回字符串形式的数值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = 520;</span><br><span class=\"line\">num.toString(); //&quot;520&quot;</span><br><span class=\"line\">Number.prototype.toString.call(num); //&quot;520&quot;</span><br></pre></td></tr></table></figure>\n\n<p>8 布尔 boolean<br>toString()：返回字符串”true”或”false”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var boo = true;</span><br><span class=\"line\">boo.toString(); //&quot;true&quot;</span><br><span class=\"line\">Boolean.prototype.toString.call(boo); //&quot;true&quot;</span><br></pre></td></tr></table></figure>\n\n<p>9 null和undefined</p>\n<blockquote>\n<p>null和undefined没有相应的构造函数，所以它们没有也无法调用toString()方法，也就是说它们不能访问任何属性和方法，只是基本类型而已。</p>\n</blockquote>\n<p>10 全局对象window（Window类）<br>toString(): 返回对象的字符串表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.toString();</span><br><span class=\"line\">&lt;!--&quot;[object Window]&quot;--&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Winodw类并没有在Window.prototype原型对象上重写toString()方法，它会顺着原型链查找调用Object.prototype.toString()。<br>所以上述代码为：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(window);</span><br><span class=\"line\">&lt;!--&quot;[object Window]&quot;--&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>toString.call()</strong><br> toString.call()和toString()直接调用一样都返回[object Undefined],</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toString.call() // [object Undefined]</span><br><span class=\"line\">toString() // [object Undefined]</span><br><span class=\"line\">window.toString.call() // [object Undefined]</span><br><span class=\"line\">window.toString.call(undefined) // [object Undefined]</span><br><span class=\"line\">Object.prototype.toString.call() // [object Undefined]</span><br><span class=\"line\">Object.prototype.toString.call(undefined) // [object Undefined]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>所以toString.call()相当于<br>window.toString.call()  -&gt; window.toString.call(undefined) -&gt; Object.prototype.toString.call()  -&gt;Object.prototype.toString.call(undefined)</p>\n</blockquote>\n<p><strong>所以用Object.prototype.toString.call() 判断类型可以简写为toString.call()来判断</strong><br>  但是要注意如果已经有定义了toString函数就不可以使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toString()&#123;</span><br><span class=\"line\">    console.log(&quot;kimi&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">toString(); //&quot;kimi&quot;</span><br><span class=\"line\">toString.call(&#123;&#125;); //&quot;kimi&quot;</span><br><span class=\"line\">toString.call([]); //&quot;kimi&quot;</span><br></pre></td></tr></table></figure>\n\n","categories":["前端技术"],"tags":["javascript基础"]},{"title":"about","url":"/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"/search/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"/link/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"/tag/index.html","content":"","categories":[],"tags":[]}]